(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{251:function(a,e,t){"use strict";t.r(e);var v=t(5),r=Object(v.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"vue相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue相关"}},[a._v("#")]),a._v(" vue相关")]),a._v(" "),t("h2",{attrs:{id:"v-show-v-if区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-show-v-if区别"}},[a._v("#")]),a._v(" v-show && v-if区别？")]),a._v(" "),t("ul",[t("li",[a._v("v-show通过css的display判断是否显示，不管是否显示DOM已经存在。如果display:none，DOM是存在的。")]),a._v(" "),t("li",[a._v("v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；")]),a._v(" "),t("li",[a._v("v-if 是判断节点是否渲染，如果频繁切换不适合使用。如果v-if为false，DOM是没有的。")])]),a._v(" "),t("p",[a._v("display:none,visible:hidden。DOM都是存在的。")]),a._v(" "),t("p",[a._v("区别是display：none会带来重排重绘。visible只会带来重排。")]),a._v(" "),t("h2",{attrs:{id:"为什么v-for中用key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么v-for中用key"}},[a._v("#")]),a._v(" 为什么v-for中用key？")]),a._v(" "),t("p",[a._v("必须有key 不能用index和random，应该用后台返回的id\ndiff算法通过tag和key来判断 是否sameNode 优化渲染次数，提升渲染性能。")]),a._v(" "),t("h2",{attrs:{id:"描述vue父子组件生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#描述vue父子组件生命周期"}},[a._v("#")]),a._v(" 描述vue父子组件生命周期？")]),a._v(" "),t("ul",[t("li",[a._v("父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted")]),a._v(" "),t("li",[a._v("子组件更新过程")]),a._v(" "),t("li",[a._v("父beforeUpdate->子beforeUpdate->子updated->父updated")]),a._v(" "),t("li",[a._v("父组件更新过程")]),a._v(" "),t("li",[a._v("父beforeUpdate->父updated")]),a._v(" "),t("li",[a._v("销毁过程")]),a._v(" "),t("li",[a._v("父beforeDestroy->子beforeDestroy->子destroyed->父destroyed")])]),a._v(" "),t("h2",{attrs:{id:"描述组件间如何通讯"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#描述组件间如何通讯"}},[a._v("#")]),a._v(" 描述组件间如何通讯？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("父子组件传值\n兄弟组件传值\n祖孙组件传值\nemitBus 和vuex的使用\n")])])]),t("h2",{attrs:{id:"描述组件渲染和更新的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#描述组件渲染和更新的过程"}},[a._v("#")]),a._v(" 描述组件渲染和更新的过程")]),a._v(" "),t("h2",{attrs:{id:"双向数据绑定的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#双向数据绑定的实现原理"}},[a._v("#")]),a._v(" 双向数据绑定的实现原理")]),a._v(" "),t("ul",[t("li",[a._v("输入框 value 绑定 data中的key name")]),a._v(" "),t("li",[a._v("给输入框绑定input的事件  this.name = $event.target.value")]),a._v(" "),t("li",[a._v("data更新触发render渲染")])]),a._v(" "),t("h2",{attrs:{id:"v-model的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-model的实现原理"}},[a._v("#")]),a._v(" v-model的实现原理")]),a._v(" "),t("p",[a._v("v-model传入数据，通过value或者自定义model接收\nmodel:{\nprop:'text'//对应到 props text\nevent:'change'\n}\n使用\n<input type=\"text\" :value=\"text\" @input=\"$emit('change',$event.target.value)\">")]),a._v(" "),t("h2",{attrs:{id:"对mvvm的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对mvvm的理解"}},[a._v("#")]),a._v(" 对MVVM的理解")]),a._v(" "),t("p",[a._v("View  ViewModel Model")]),a._v(" "),t("h2",{attrs:{id:"computed-和-watch的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch的区别"}},[a._v("#")]),a._v(" computed 和 watch的区别？")]),a._v(" "),t("ul",[t("li",[a._v("缓存 data不变不会重新计算 提高性能")])]),a._v(" "),t("h2",{attrs:{id:"为什么data被设计一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么data被设计一个函数"}},[a._v("#")]),a._v(" 为什么data被设计一个函数？")]),a._v(" "),t("p",[a._v("vue文件实际被编译出来是一个class，每个地方使用组件相当于是对class的一个实例化，在实例化时候如果data不是函数，每个组件都会共享同一个data。")]),a._v(" "),t("h2",{attrs:{id:"ajax请求应该放在哪个生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ajax请求应该放在哪个生命周期"}},[a._v("#")]),a._v(" ajax请求应该放在哪个生命周期？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("js是单线程，ajax异步获取数据。放在mounted之前没任何作用。\n")])])]),t("p",[a._v("正确姿势中获取数据。 mounted之前，要完成observe，render过程。即使提前获取数据也没有什么作用。")]),a._v(" "),t("h2",{attrs:{id:"如何将组件所有props传递给子组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何将组件所有props传递给子组件"}},[a._v("#")]),a._v(" 如何将组件所有props传递给子组件？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('    - $props\n    <User v-bind="$props" />\n')])])]),t("h2",{attrs:{id:"多个组件有相同逻辑-如何抽离"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多个组件有相同逻辑-如何抽离"}},[a._v("#")]),a._v(" 多个组件有相同逻辑，如何抽离？")]),a._v(" "),t("p",[a._v("使用mixin\nmixin的一些缺点")]),a._v(" "),t("h2",{attrs:{id:"何时使用异步组件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#何时使用异步组件"}},[a._v("#")]),a._v(" 何时使用异步组件？")]),a._v(" "),t("ul",[t("li",[a._v("加载大组件 比如 加载编辑器组件 加载图表")]),a._v(" "),t("li",[a._v("路由异步加载 切换路由异步加载")])]),a._v(" "),t("h2",{attrs:{id:"keep-alive何时使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive何时使用"}},[a._v("#")]),a._v(" keep-alive何时使用？")]),a._v(" "),t("p",[a._v("比如静态的tab页 header等。")]),a._v(" "),t("h2",{attrs:{id:"什么是作用域插槽"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是作用域插槽"}},[a._v("#")]),a._v(" 什么是作用域插槽？")]),a._v(" "),t("h2",{attrs:{id:"vuex中action-和-mutation有何区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex中action-和-mutation有何区别"}},[a._v("#")]),a._v(" Vuex中action 和 mutation有何区别？")]),a._v(" "),t("ul",[t("li",[a._v("action中处理异步，mutation不可以")]),a._v(" "),t("li",[a._v("mutation做原子操作")]),a._v(" "),t("li",[a._v("action可以整合多个mutation")])]),a._v(" "),t("h2",{attrs:{id:"vue-router常用路由模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router常用路由模式"}},[a._v("#")]),a._v(" Vue-router常用路由模式")]),a._v(" "),t("ul",[t("li",[a._v("hash默认\n主要对onHashChange函数做一些处理")]),a._v(" "),t("li",[a._v("history模式(需要服务端支持) 后端需要路径全覆盖返回前端index页"),t("br"),a._v("\nhistory 根据 html5的 history.pushState")]),a._v(" "),t("li",[a._v("abstract\n适用于所有JavaScript环境，例如服务器端使用Node.js。如果没有浏览器API，路由器将自动被强制进入此模式。")])]),a._v(" "),t("h2",{attrs:{id:"如何配置vue-router异步加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何配置vue-router异步加载"}},[a._v("#")]),a._v(" 如何配置Vue-router异步加载")]),a._v(" "),t("p",[a._v("router:[\n{\npath:'/',\ncomponent: ()=> import(\n'../src/heelo'\n)\n}\n]")]),a._v(" "),t("h2",{attrs:{id:"请用vnode描述一个dom结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#请用vnode描述一个dom结构"}},[a._v("#")]),a._v(" 请用vnode描述一个DOM结构")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("<div id=\"div1\" class=\"container\" >\n    <p>vdom</p>\n    <ul style=\"font-size:10px\">\n        <li>111</li>\n    </ul>\n</div>\n\n{\n    tag:\"div\",\n    props:{\n        className:'container',\n        id'div1'\n    },\n    children:[\n        {\n            tag:'p',\n            children:'vdom'\n        },{\n            tag:'ul',\n            props:{style:'font-size:20px;'},\n            children:{\n                tag:'li',\n                children:'111 '\n            }\n        }\n    ]\n}\n")])])]),t("h1",{attrs:{id:"vue监听data变化-响应式原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue监听data变化-响应式原理"}},[a._v("#")]),a._v(" vue监听data变化，响应式原理")]),a._v(" "),t("ul",[t("li",[a._v("监听数组")]),a._v(" "),t("li",[a._v("监听对象")])]),a._v(" "),t("p",[a._v("Object.defineProperty缺点"),t("br"),a._v("\n不能监听数组变化。")]),a._v(" "),t("h2",{attrs:{id:"diff算法事件复杂度问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#diff算法事件复杂度问题"}},[a._v("#")]),a._v(" diff算法事件复杂度问题")]),a._v(" "),t("p",[a._v("o(n3次方) 降低到O(n) 并描述diff算法过程")]),a._v(" "),t("h2",{attrs:{id:"简述-diff算法过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#简述-diff算法过程"}},[a._v("#")]),a._v(" 简述 diff算法过程")]),a._v(" "),t("ul",[t("li",[a._v("patch(elem,vnode) patch（vnode,newVnode）")]),a._v(" "),t("li",[a._v("patchVnode 和 addVnodes 和 removeVnodes")]),a._v(" "),t("li",[a._v("updateChildren(key 的重要性)")])]),a._v(" "),t("h2",{attrs:{id:"vue为何是异步渲染-nexttick作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue为何是异步渲染-nexttick作用"}},[a._v("#")]),a._v(" Vue为何是异步渲染， $nextTick作用？")]),a._v(" "),t("ul",[t("li",[a._v("异步渲染 (以及合并data修改)，以提高渲染性能。")]),a._v(" "),t("li",[a._v("$nextTick在DOM更新之后，触发回调。")])]),a._v(" "),t("h2",{attrs:{id:"v-for为什么不能和v-if一起使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-for为什么不能和v-if一起使用"}},[a._v("#")]),a._v(" v-for为什么不能和v-if一起使用？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("因为在代码执行的时候，v-if会优先执行 每次循环都会进行一次 v-if的判断很浪费性能。所以v-if和v-for同时存在时候。vue会报错。\n正确应该在v-for外层嵌套div进行v-for的判断。\n如果一个list内部的某些flag需要判断应该如何做，可以通过computed把需要展示的数据做过滤。\n避免list循环内部v-if的判断。\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('    <div v-for="item in list" v-if="">\n')])])]),t("h2",{attrs:{id:"vue中为什么data被设计为函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中为什么data被设计为函数"}},[a._v("#")]),a._v(" vue中为什么data被设计为函数?")]),a._v(" "),t("p",[a._v("为了让每个组件实例维护属于自己的一个data，如果data不是函数，会造成多个组件公用同一个data对象。")]),a._v(" "),t("h2",{attrs:{id:"vue中如何使用-插件-plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中如何使用-插件-plugin"}},[a._v("#")]),a._v(" vue中如何使用 插件 Plugin？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let MyPlugin = {}\nMyPlugin.install = function(Vue,options){\n    //增加全局方法\n    Vue.globalMethod = function (){\n        console.log('全局方法   ')\n    }\n    //增加自定义指令\n    Vue.directive('direct',{\n        bind(){\n            console.log('指令绑定成功')\n        }\n    })\n    //增加过滤器\n     Vue.filter('msgFormat', function(msg) {   \n            return msg.replace(/单纯/g, 'xxx')\n    })\n    //mixin\n    Vue.mixin({\n        create(){\n            console.log('公共mouted')\n        }\n    })\n}\nexport default MyPlugin\nvue.use(myPlugin)\n")])])]),t("h2",{attrs:{id:"vue路由懒加载-和-全量加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue路由懒加载-和-全量加载"}},[a._v("#")]),a._v(" vue路由懒加载 和 全量加载？")]),a._v(" "),t("p",[a._v("如果不配置路由懒加载，路由会全量加载，既第一次请求首页就把所有的资源都加载回来。\n如果配置路由懒加载切换到对应的路由才会加载到对应的路由下资源，可以减少首次请求资源的体积。")]),a._v(" "),t("p",[a._v("component:()=>{\nimport('../view/about.vue')\n}")]),a._v(" "),t("h2",{attrs:{id:"vue中-for时为什么要有key"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue中-for时为什么要有key"}},[a._v("#")]),a._v(" vue中 for时为什么要有key?")]),a._v(" "),t("p",[a._v("根据dom生成virtual DOM，当virtual Dom上的某个dom节点数据改变后会生成一个新的Vnode,新旧节点对比，发现有修改的地方就直接渲染到真实的dom树上。\n（即新旧节点对比，方便快速找到要更新的节点）")]),a._v(" "),t("div",{staticClass:"language-angular2html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("//不使用key 一个数组  arr=['1','2','3','4','5','6']。\n<view v-for='arr'>\n        {{item}}\n</view>\n//上面代码会生成6个div每个div对应的arr中的数字。现在我们将arr变成[0, 1, 2, 3, 7, 8, 9]。\n//更新渲染的步骤时这样的原先div中的1变成0 2变成1以此类推最后新增一个div内容为9。\nVue会通过改变原来元素的内容和增加/减少元素来完成这个改变，因为没有key属性，Vue无法跟踪每个节点，只能通过这样的方法来完成变更。\n")])])]),t("h2",{attrs:{id:"vue常见性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue常见性能优化"}},[a._v("#")]),a._v(" Vue常见性能优化")]),a._v(" "),t("ul",[t("li",[a._v("合理使用v-if v-show")]),a._v(" "),t("li",[a._v("合理使用computed")]),a._v(" "),t("li",[a._v("v-for 增加key")]),a._v(" "),t("li",[a._v("自定义事件 DOM事件及时销毁 event.$off removeEventListener  清除timer")]),a._v(" "),t("li",[a._v("合理使用异步组件")]),a._v(" "),t("li",[a._v("合理使用 keep-alive")]),a._v(" "),t("li",[a._v("data层级不要太深")]),a._v(" "),t("li",[a._v("webpack层的优化")])])])}),[],!1,null,null,null);e.default=r.exports}}]);