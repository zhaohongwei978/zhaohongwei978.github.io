(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{241:function(t,e,n){"use strict";n.r(e);var a=n(5),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"js-问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-问题"}},[t._v("#")]),t._v(" js 问题")]),t._v(" "),n("h2",{attrs:{id:"underfind-和-null-的区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#underfind-和-null-的区别"}},[t._v("#")]),t._v(" underfind 和 null 的区别?")]),t._v(" "),n("p",[t._v('JavaScript 语言居然有两个表示"无"的值：undefined 和 null。\n最初设计')]),t._v(" "),n("ul",[n("li",[t._v('null 是一个表示"无"的对象，转为数值时为 0；\n// Number(null) 0')]),t._v(" "),n("li",[t._v('undefined 是一个表示"无"的原始值，转为数值时为 NaN。\n// Number(undefined)')])]),t._v(" "),n("h3",{attrs:{id:"null-和-underfind-目前的用法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#null-和-underfind-目前的用法"}},[t._v("#")]),t._v(" null 和 underfind 目前的用法")]),t._v(" "),n("p",[t._v('null 表示"没有对象"，即该处不应该有值。\nundefined 表示"缺少值"，就是此处应该有一个值，但是还没有定义。')]),t._v(" "),n("ul",[n("li",[t._v("1 变量被声明了，但没有赋值时，就等于 undefined。")]),t._v(" "),n("li",[t._v("2 调用函数时，应该提供的参数没有提供，该参数等于 undefined。")]),t._v(" "),n("li",[t._v("3 对象没有赋值的属性，该属性的值为 undefined。")]),t._v(" "),n("li",[t._v("4 函数没有返回值时，默认返回 undefined。")])]),t._v(" "),n("p",[t._v("这样判断一个值是否存在，就可以用\nobjA.valueA === undefined // 不应使用 null 因为 undefined == null，而 null 表示该值定义为空值。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("underfind === null // false\ntypeof underfind //underdind\ntypeof null //object\n")])])]),n("h3",{attrs:{id:"javascript-中包含-6-种数据类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中包含-6-种数据类型"}},[t._v("#")]),t._v(" JavaScript 中包含 6 种数据类型？")]),t._v(" "),n("p",[t._v("5 种基本数据类型 1 个复杂数据类型")]),t._v(" "),n("ul",[n("li",[t._v("underfind")]),t._v(" "),n("li",[t._v("null")]),t._v(" "),n("li",[t._v("string")]),t._v(" "),n("li",[t._v("number")]),t._v(" "),n("li",[t._v("boolean")]),t._v(" "),n("li",[t._v("object")])]),t._v(" "),n("h3",{attrs:{id:"清除浮动的写法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动的写法"}},[t._v("#")]),t._v(" 清除浮动的写法")]),t._v(" "),n("ul",[n("li",[t._v("1 overfow:hidden")]),t._v(" "),n("li",[t._v('2 元素末尾追加 div.style="clear:both"')]),t._v(" "),n("li",[t._v("3 通过伪类")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v(".clearfix::after{\n    content:'' //伪元素内容 为''让伪元素不显示\n    //clear属性只能在块级元素上其作用，这就是清除浮动样式中display:block的作用。\n    display:'block',\n    height:0让元素高度为0并且不显示\n    clear:both;//清除浮动\n    visiblity:hidden;//让元素渲染但是不显示\n    clear:both;//清除浮动\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("清除浮动作用\n\n1:解决子元素浮动父元素高度塌陷的问题\n")])])]),n("h2",{attrs:{id:"_1px不精准问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1px不精准问题"}},[t._v("#")]),t._v(" 1px不精准问题？")]),t._v(" "),n("p",[t._v("现象，在高清屏下，移动端的1px 会很粗。")]),t._v(" "),n("h3",{attrs:{id:"为什么会出现1px不精准"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么会出现1px不精准"}},[t._v("#")]),t._v(" 为什么会出现1px不精准？")]),t._v(" "),n("p",[t._v("DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。")]),t._v(" "),n("p",[t._v("目前主流的屏幕DPR=2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。")]),t._v(" "),n("ul",[n("li",[t._v("window.devicePixelRatio=物理像素 /CSS像素")])]),t._v(" "),n("h3",{attrs:{id:"方法1-通过border-img"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法1-通过border-img"}},[t._v("#")]),t._v(" 方法1 通过border-img")]),t._v(" "),n("div",{staticClass:"language-angular2 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("  border: 1px solid transparent;\n  border-image: url('./../../image/96.jpg') 2 repeat;\n")])])]),n("h3",{attrs:{id:"方法2-使用box-shadow实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法2-使用box-shadow实现"}},[t._v("#")]),t._v(" 方法2 使用box-shadow实现")]),t._v(" "),n("p",[t._v("仔细看,能看出这是阴影不是边框。")]),t._v(" "),n("div",{staticClass:"language-angular2 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("box-shadow: x偏移量 y偏移量 偏移半径 颜色;\nbox-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线\n            1px  0  1px -1px #e5e5e5,   //右边线\n            0  1px  1px -1px #e5e5e5,   //下边线\n            -1px 0  1px -1px #e5e5e5;   //左边线\n")])])]),n("h3",{attrs:{id:"方法3-在伪元素中定位-通过transform缩放"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#方法3-在伪元素中定位-通过transform缩放"}},[t._v("#")]),t._v(" 方法3 在伪元素中定位，通过transform缩放")]),t._v(" "),n("div",{staticClass:"language-angular2 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("setOnePx{\n  position: relative;\n  &::after{\n    position: absolute;\n    content: '';\n    background-color: #e5e5e5;\n    display: block;\n    width: 100%;\n    height: 1px; /*no*/\n    transform: scale(1, 0.5);\n    top: 0;\n    left: 0;\n  }\n}\n")])])]),n("h3",{attrs:{id:"设置viewport的scale值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#设置viewport的scale值"}},[t._v("#")]),t._v(" 设置viewport的scale值")]),t._v(" "),n("div",{staticClass:"language-angular2 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<meta name=\"viewport\" id=\"WebViewport\" content=\"initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no\">\n<script>\n          var viewport = document.querySelector(\"meta[name=viewport]\");\n          //下面是根据设备像素设置viewport\n          if (window.devicePixelRatio == 1) {\n              viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');\n          }\n          if (window.devicePixelRatio == 2) {\n              viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no');\n          }\n          if (window.devicePixelRatio == 3) {\n              viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no');\n          }\n          var docEl = document.documentElement;\n          var fontsize = 32* (docEl.clientWidth / 750) + 'px';\n          docEl.style.fontSize = fontsize;\n      <\/script>\n")])])]),n("h2",{attrs:{id:"前端性能监控"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前端性能监控"}},[t._v("#")]),t._v(" 前端性能监控？")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("通过performance API 包含了页面加载的各个阶段的起始时间")])]),t._v(" "),n("li",[n("p",[t._v("window.performance")])]),t._v(" "),n("li",[n("p",[t._v("打印window.performance.timing")])])]),t._v(" "),n("div",{staticClass:"language-angular2 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    timing: {\n        navigationStart: 同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。\n        unloadEventStart: 上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。\n        unloadEventEnd: 和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。\n        redirectStart: 第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。\n        redirectEnd: 最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0. \n        fetchStart: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。\n        domainLookupStart: DNS 域名查询开始的UNIX时间戳,如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。\n        domainLookupEnd: DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等\n        connectStart: HTTP（TCP） 域名查询结束的时间戳，如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。\n        connectEnd: HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳，如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。\n        secureConnectionStart: HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。\n        requestStart: 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。\n        responseStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳，如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。\n        responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。\n        domLoading: 当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。\n        domInteractive: 当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。\n        domContentLoadedEventStart: 当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。\n        domContentLoadedEventEnd: 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。\n        domComplete: 当前文档解析完成，即Document.readyState 变为 'complete'且相对应的readystatechange 被触发时的时间戳\n        loadEventStart: load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。\n        loadEventEnd: 当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0。\n}\n")])])]),n("div",{staticClass:"language-angular2 extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 重定向耗时\nredirect: timing.redirectEnd - timing.redirectStart,\n// DOM 渲染耗时\ndom: timing.domComplete - timing.domLoading,\n// 页面加载耗时\nload: timing.loadEventEnd - timing.navigationStart,\n// 页面卸载耗时\nunload: timing.unloadEventEnd - timing.unloadEventStart,\n// 请求耗时\nrequest: timing.responseEnd - timing.requestStart,\n// 获取性能信息时当前时间\ntime: new Date().getTime(),\n\n//白屏时间指从输入网址，到页面开始显示内容的时间。\n<script>\n    let whiteScreen = new Date() - performance.timing.navigationStart\n<\/script>\n")])])]),n("h2",{attrs:{id:"oject-assign-的浅拷贝问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#oject-assign-的浅拷贝问题"}},[t._v("#")]),t._v(" Oject.assign 的浅拷贝问题？")]),t._v(" "),n("p",[t._v("Object.assign 只能拷贝第一层。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let a = {a:1,b:2}\nlet b= {c:3,d:{name:'kira'}};\n\nlet obj = Object.assign({},a,b);\nconsole.log(obj);\n//{ a: 1, b: 2, c: 3, d: { name: 'kira' } }\n\na.a = 66;\nconsole.log(obj); //修改a发现obj并没有被改变。\n// { a: 1, b: 2, c: 3, d: { name: 'kira' } }\nb.d.name = 'test';\nconsole.log(obj);//修改name时候，发现obj被改变了。\n//{ a: 1, b: 2, c: 3, d: { name: 'test' } }\nc\n")])])]),n("h2",{attrs:{id:"js-实现一个单例模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js-实现一个单例模式"}},[t._v("#")]),t._v(" js 实现一个单例模式")]),t._v(" "),n("p",[t._v("思路：保证一个类只有一个对象，一般先判断对象是否存在，如果存在直接返回该对象。如果不存在，创建对象并返回。\n比如后台的 jdbc 连接就是典型的单例，防止每次使用 sql 都要创建 sql 连接对象。")]),t._v(" "),n("h2",{attrs:{id:"requestanimationframe-对比-settimeout"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-对比-settimeout"}},[t._v("#")]),t._v(" requestAnimationFrame 对比 setTimeOut")]),t._v(" "),n("ul",[n("li",[t._v("没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。")]),t._v(" "),n("li",[t._v("把浏览器切换到后台，setTimeOut 还会一直执行。")]),t._v(" "),n("li",[t._v("在页面渲染结束后才会开始执行。")]),t._v(" "),n("li",[t._v("requestAnimationFrame 执行时机早，在重绘阶段 就开始执行了。")]),t._v(" "),n("li",[t._v("动画更加流畅 60 帧/s，既 16.67ms 更新一次视图。这个时机是符合人眼的。频率是自己定的")]),t._v(" "),n("li",[t._v("setTimeOut 手动设置多少毫秒增加多少像素，requestAnimationFrame 自动控制.\nsetTimeOut 手动设置时间来执行，如果手动设置 setTimeOut(fn,0)执行代码前等待的毫秒数为 0，但并不是立即执行的，这是因为 setTimeout 有一个最小执行时间。")])]),t._v(" "),n("p",[t._v("HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔）不得低于 4 毫秒。实际上可能为 4 毫秒后才事件推入任务队列。如果此时主线程不为空，也不会读取推出异步队列的 setTimeOut.")]),t._v(" "),n("p",[t._v("执行效率问题")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("虽然两段代码执行效果一样，但是第二段代码(16.7ms/3)就要执行一次函数，很浪费性能。\n如果每次增加10或者更大，使用setTimeOut会有明显卡顿卡。\nlet currentWidth = 100\nconst maxWidth = 640\nfunction animate()\n    currentWidth + = 3;\n    if(currentWidth<maxWidth){\n        $div.css('left',currentWidth)\n        setTimeOut(animate,16.7)\n    }\n}\nanimate();\n\n//假设我们让每次增加1px\nlet currentWidth = 100\nconst maxWidth = 640\nfunction animate()\n    currentWidth + = 1;//每次增加1px\n    if(currentWidth<maxWidth){\n        $div.css('left',currentWidth)\n        setTimeOut(animate,16.7/3) //增加setTimeOut的执行频率\n    }\n}\nanimate();\n")])])]),n("h2",{attrs:{id:"documentfragement-vs-document"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#documentfragement-vs-document"}},[t._v("#")]),t._v(" DocumentFragement VS Document")]),t._v(" "),n("ul",[n("li",[t._v("区别:DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。")])]),t._v(" "),n("p",[t._v("DocumentFragment 节点代表一个文档的片段，本身是一个完整的 DOM 树结构。它没有父节点，不属于 Document。但是可以插入任意数量的子节点。但是它不属于当前文档。比直接操作 DOM 树快。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//简单使用\nvar carInfoEl = document.querySelector('.car-info')\nconst fragment = document.createDocumentFragment() //创建fragement\ncarDetail.carInfo.map(item => {\n      var li = document.createElement('li')\n      li.innerHTML = '<span class=\"key\">' + item.split(':')[0] + '</span > <span span class=\"value\" >' + item.split(':')[1] + '</span>'\n      fragment.appendChild(li)//把真实DOM append到 fragement上\n})\ncarInfoEl.appendChild(fragment) //把fragement添加到真实DOM上。\n")])])]),n("h2",{attrs:{id:"在前端如何处理几万条数据的情况"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在前端如何处理几万条数据的情况"}},[t._v("#")]),t._v(" 在前端如何处理几万条数据的情况？")]),t._v(" "),n("p",[t._v("通过使用 DocumentFragement。存储每次要插入的文档。\n使用 requestAnimationFragement 动态 在真实 DOM 上添加 fragement。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    setTimeout(() => {\n    // 插入十万条数据\n    const total = 100000;\n    // 一次插入的数据\n    const once = 20;\n    // 插入数据需要的次数\n    const loopCount = Math.ceil(total / once);\n    let countOfRender = 0;\n    const ul = document.querySelector('ul');\n    // 添加数据的方法\n    function add() {\n        const fragment = document.createDocumentFragment();\n        for(let i = 0; i < once; i++) {\n        const li = document.createElement('li');\n        li.innerText = Math.floor(Math.random() * total);\n        fragment.appendChild(li);\n        }\n        ul.appendChild(fragment);\n        countOfRender += 1;\n        loop();\n    }\n    function loop() {\n        if(countOfRender < loopCount) {\n        window.requestAnimationFrame(add);\n        }\n    }\n    loop();\n    }, 0)\n\n")])])]),n("h2",{attrs:{id:"promise-状态不能被二次改变问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#promise-状态不能被二次改变问题"}},[t._v("#")]),t._v(" Promise 状态不能被二次改变问题")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("new Promise(function(resolve,reject){\n    resoleve()\n    throw Error('error')\n}).then(function(){\n    console.log('resolve')\n}).catch(function(){\n    console.log('err')\n})\n//打印结果 resolve\nthrow Error 并不会触发 catch 的执行\n")])])]),n("h2",{attrs:{id:"原型链问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型链问题"}},[t._v("#")]),t._v(" 原型链问题")]),t._v(" "),n("p",[t._v("此题考察的是对原型链继承关系的理解，和对 new 的认识。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Object.prototype.a = function(){\n    console.log('object')\n}\nFunction.prototype.a = function(){\n    consoloe.log('function')\n}\nfunction A(){\n\n}\n\nlet a = new A();\na.a(); // 打印结果是 object，找的是Object上的a\n因为 我们new A();首先a会在 构造函数上找，构造函数上找不到。\nnew的过程\n1创建空对象{}\n2把a的原型链指向Object\n")])])]),n("h2",{attrs:{id:"for-in-对比-for-of"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-in-对比-for-of"}},[t._v("#")]),t._v(" for in 对比 for of")]),t._v(" "),n("h3",{attrs:{id:"for-in-是为普通对象设计的"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-in-是为普通对象设计的"}},[t._v("#")]),t._v(" for-in 是为普通对象设计的")]),t._v(" "),n("h3",{attrs:{id:"for-of-遍历数组更加方便"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#for-of-遍历数组更加方便"}},[t._v("#")]),t._v(" for-of 遍历数组更加方便")])])}),[],!1,null,null,null);e.default=r.exports}}]);