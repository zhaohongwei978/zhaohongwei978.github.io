(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{254:function(e,t,n){"use strict";n.r(t);var a=n(5),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"nexttick-实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-实现"}},[e._v("#")]),e._v(" nextTick 实现")]),e._v(" "),n("ul",[n("li",[e._v("1 数据发生变化，触发 setter")]),e._v(" "),n("li",[e._v("2 dep.notice()触发 dep 下的 weather")]),e._v(" "),n("li",[e._v("3 weatcher.update(),update 有同步更新，和异步更新（queueWeather）。")]),e._v(" "),n("li",[e._v("4 将一个观察者对象 weather,push 进 queue 队列，在 queue 队列中已经存在相同的 id 则该观察者对象 weather 将被跳过.利用 hash 的 map 结构 对 weather 去重，防止相同的 weather 被重复添加到 queue 中。")]),e._v(" "),n("li",[e._v("6 nextTick 利用事件循环，在一下次 tick 时，flushSchedulerQueue 执行所有 queue 队列中的 weather，更新视图。")])]),e._v(" "),n("h2",{attrs:{id:"nexttick-的表现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-的表现"}},[e._v("#")]),e._v(" nextTick 的表现？")]),e._v(" "),n("p",[e._v("打印的结果是 begin，为什么我们明明已经将 test 设置成了“end”,获取真实 DOM 节点的 innerText 却没有得到我们预期中的“end”，可见该操作是异步的。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<template>\n  <div>\n    <div ref=\"test\">{{test}}</div>\n    <button @click=\"handleClick\">tet</button>\n  </div>\n</template>\nexport default {\n    data () {\n        return {\n            test: 'begin'\n        };\n    },\n    methods () {\n        handleClick () {\n            this.test = 'end';\n            console.log(this.$refs.test.innerText);//打印“begin”\n        }\n    }\n}\n\n")])])]),n("p",[e._v("通过 nextTick，我们可以拿到 DOM 操作之后的结果。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('<template>\n\t<div class="" id="app">\n\t\t<span ref="msg">{{msg}}</span>\n\t    <button @click="change">button</button>\n  </div>\n</template>\n\n<script>\nexport default {\n\tname: \'app\',\n\tdata(){\n\t\treturn{\n\t\t\tmsg:\'1111\'\n\t\t}\n\t},\n\tmethods:{\n\t\tchange(){\n\n            this.msg = "222"\n            console.log(\'1111\',this.$refs.msg.innerHTML) //打印结果 111\n\t\t\tthis.$nextTick(()=>{\n\t\t\t\tconsole.log(\'1111\',this.$refs.msg.innerHTML) //打印结果 222\n\t\t\t})\n\t\t},\n\t}\n}\n<\/script>\n')])])]),n("h2",{attrs:{id:"数据变化时-weather-如何更新"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#数据变化时-weather-如何更新"}},[e._v("#")]),e._v(" 数据变化时，weather 如何更新？")]),e._v(" "),n("ul",[n("li",[e._v("1 数据发生变化，触发 setter")]),e._v(" "),n("li",[e._v("2 dep.notice()触发 dep 下的 weather")]),e._v(" "),n("li",[e._v("3 weatcher.update(),update 有同步更新，和异步更新（queueWeather）。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n        this.dirty = true\n    } else if (this.sync) {\n        /*同步则执行run直接渲染视图*/\n        this.run()\n    } else {\n        /*异步推送到观察者队列中，下一个tick时调用。*/\n        queueWatcher(this)\n    }\n}\n")])])]),n("h2",{attrs:{id:"queueweather-对-weather-去重"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#queueweather-对-weather-去重"}},[e._v("#")]),e._v(" queueWeather 对 weather 去重？")]),e._v(" "),n("ul",[n("li",[e._v("1 将一个观察者对象 weather,push 进 queue 队列，在 queue 队列中已经存在相同的 id 则该观察者对象 weather 将被跳过.")]),e._v(" "),n("li",[e._v("2 利用 hash 的 map 结构 对 weather 去重，防止相同的 weather 被重复添加到 queue 中。")]),e._v(" "),n("li",[e._v("3 nextTick 利用事件循环，在一下次 tick 时，执行所有 queue 队列中的 weather，更新视图。")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let has = {};\nlet queue = [];\nlet waiting = false;\n\nfunction queueWatcher(watcher) {\n    //获取weather的id\n    const id = watcher.id;\n    if (has[id] == null) {\n        has[id] = true; // {'1':true,'2':true}\n        queue.push(watcher);\n\n        if (!waiting) {\n            waiting = true;\n            nextTick(flushSchedulerQueue);\n        }\n    }\n}\n\n## \n\nfunction flushSchedulerQueue () {\n    let watcher, id;\n\n    for (index = 0; index < queue.length; index++) {\n        watcher = queue[index];\n        id = watcher.id;\n        has[id] = null;\n        watcher.run();\n    }\n\n    waiting  = false;\n}\n")])])]),n("h2",{attrs:{id:"为什么会使用-nexttick"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么会使用-nexttick"}},[e._v("#")]),e._v(" 为什么会使用 nextTick?")]),e._v(" "),n("p",[e._v("vue 中我们修改 data 中的 key，并不可能每一次修改 data 中的 key 都要渲染一下页面。在 vue 中会把多次对 data 中 key 的修改合并，放在一个事件循环中，然后利用事件循环机制，当前这个事件循环对 key 的所有修改都结束会调用一个 nextTick 函数，标志此时渲染结束。")]),e._v(" "),n("p",[e._v("事件循环的事件执行完，先通过 Promise 实现 nextTick 如果 nextTick 不支持使用 MucationObserver 如果 MucationObserver 不支持使用 setTimeOut。")]),e._v(" "),n("p",[e._v("修改数据时，视图并不会即时的更新，而是等在同一事件循环的所有数据变化完成后，再进行视图更新。类似于 Event Loop 事件循环机制。")]),e._v(" "),n("p",[e._v("Vue 实现响应式并不是在数据改变后就立即更新 DOM，而是在一次事件循环的所有数据变化后再异步执行 DOM 更新.")]),e._v(" "),n("p",[e._v("nextTick")]),e._v(" "),n("h2",{attrs:{id:"为什么我们频繁修改-data-属性-不会多次更新-view"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么我们频繁修改-data-属性-不会多次更新-view"}},[e._v("#")]),e._v(" 为什么我们频繁修改 data 属性，不会多次更新 view？")]),e._v(" "),n("p",[e._v("当我们同时修改多次 data 属性时候，该判断 if (has[id] == null) 防止重复添加更新任务，并且利用了 event loop 机制在合适的时机去更新视图。")]),e._v(" "),n("p",[e._v("在 update 方法中，实际调用 nextTick 更新视图。\n在事件循环中，当前宏任务调用栈清空才会去执行微任务。")])])}),[],!1,null,null,null);t.default=s.exports}}]);