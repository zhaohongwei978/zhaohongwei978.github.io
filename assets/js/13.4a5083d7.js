(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{214:function(t,e,a){t.exports=a.p+"assets/img/20191022172607993.56f26a00.png"},267:function(t,e,a){"use strict";a.r(e);var n=a(5),i=Object(n.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"虚拟-dom"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom"}},[t._v("#")]),t._v(" 虚拟 DOM")]),t._v(" "),n("h2",{attrs:{id:"virtual-dom-运行过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-运行过程"}},[t._v("#")]),t._v(" Virtual Dom 运行过程：")]),t._v(" "),n("p",[n("img",{attrs:{src:a(214),alt:"1599408879599.jpg"}})]),t._v(" "),n("ul",[n("li",[t._v("正常的 DOM 节点在 HTML 中是这样的：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<div id="main">\n    <p>文本内容</p>\n    <p>文本内容</p>\n</div>\n')])])]),n("ul",[n("li",[t._v("用 Virtual Dom 创建的 JavaScript 对象一般会是这样的：")])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("var vNode = {\n    tag: 'div',\n    attributes:{\n        id: 'main'\n    },\n    children: {\n        //p节点\n    }\n}\n")])])]),n("ul",[n("li",[n("p",[t._v("Virtual Dom 就是通过一种 VNode 类表达的，每个 DOM 元素或组件都对应一个 VNode 对象。")]),t._v(" "),n("p",[t._v("每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。")])])]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("export interface VNode{\n    tag?: string;\n    data?: VNodeData;\n    children?: VNode[];\n    text?: string;\n    elm?: Node;\n    ns?: string;\n    context?: Vue;\n    key?: string | number;\n    componentOptions?: VNodeComponentOptions;\n    componentInstance?: Vue;\n    parent?: VNode;\n    raw?: boolean;\n    isStatic?: boolean;\n    isRootInsert: boolean;\n    isComment: boolean;\n}\n")])])]),n("p",[t._v("树 diff 的时间复杂度 o(n 的三次 3)\n过程 1 遍历 tree1，第二遍历 tree2 第三排序，这三个循环一组合就是 o(n 的三次 3)")]),t._v(" "),n("p",[t._v("优化时间复杂度到(O(n))")]),t._v(" "),n("ul",[n("li",[t._v("只同级比较，不跨级比较")]),t._v(" "),n("li",[t._v("tag 不相同，直接删掉重建，不再深度比较")]),t._v(" "),n("li",[t._v("tag 和 key，两者都相同，则认为是相同节点，不再深度比较")])]),t._v(" "),n("h2",{attrs:{id:"diff-算法-比较策略-深度优先-同层比较"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#diff-算法-比较策略-深度优先-同层比较"}},[t._v("#")]),t._v(" Diff 算法 比较策略 深度优先，同层比较")]),t._v(" "),n("p",[t._v("snabbdom")]),t._v(" "),n("ul",[n("li",[t._v("相同的 vnode，（key 和 tag 都相同）patch 对比，不同的 vnode 销毁重建")])]),t._v(" "),n("h2",{attrs:{id:"如何理解-vue-中的-diff-算法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何理解-vue-中的-diff-算法"}},[t._v("#")]),t._v(" 如何理解 vue 中的 Diff 算法？")]),t._v(" "),n("ul",[n("li",[t._v("diff 算法是虚拟 DOM 技术的必然产物，通过新旧虚拟 DOm 的对比（既 Diff）将变化的地方更新在真实 DOM 上，另外也需要 Diff 高效的执行对比过程，从而降低时间复杂度 O(n).")]),t._v(" "),n("li",[t._v("vue2.x 为了降低 watcher 的颗粒度，每个组件只有一个 watcher，引入 Diff 可以精准找到 DOM 变化的地方。")]),t._v(" "),n("li",[t._v("vue 中 diff 执行时候组件实例执行更新函数时。它会对比上一次渲染结果 oldNode 和新的渲染结果 newNode。此过程称为 patch。")]),t._v(" "),n("li",[t._v("diff 过程深度优先，同层比较。两个节点之间会根据他们是否拥有子节点或者文本节点做不同操作。比较两组子节点是算法的重点。假设头尾节点可能相同做 4 次比对尝试。如果 没有找到相同节点才按照通用方式遍历查找。查找结束在按情况处理剩下节点，借助 key 通常可以精准的找到相同节点，因此整个 patch 过程很高效。")])])])}),[],!1,null,null,null);e.default=i.exports}}]);