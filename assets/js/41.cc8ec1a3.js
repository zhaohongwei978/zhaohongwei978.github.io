(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{231:function(e,t,n){"use strict";n.r(t);var a=n(5),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"模版编译"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模版编译"}},[e._v("#")]),e._v(" 模版编译")]),e._v(" "),n("h2",{attrs:{id:"模版渲染过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#模版渲染过程"}},[e._v("#")]),e._v(" 模版渲染过程")]),e._v(" "),n("p",[e._v("vue template complier，将模版编译为render函数（利用with函数），执行render函数生成vnode。\n模版不是html 有指令 插值 js表达式 能实现判断 循环")]),e._v(" "),n("p",[e._v("模版通过compile 生成AST，AST通过render编译生成 VNode代码片段。\n基于VNode我们执行patch和diff。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("const compiler = require('vue-template-compiler');\n//template模版\nconst template = `\n<p id=\"container\">\n   <span v-if=\"flag === 'a' \">A</span>\n   <span v-else>B</span>\n</p>\n`;\n\n//模版编译生成AST\nconst res = compiler.compile(template);\nconsole.log(res);\n{\n  ast: {\n    type: 1,\n    tag: 'p',\n    attrsList: [ [Object] ],\n    attrsMap: { id: 'container' },\n    rawAttrsMap: {},\n    parent: undefined,\n    children: [ [Object] ],\n    plain: false,\n    attrs: [ [Object] ],\n    static: false,\n    staticRoot: false\n  },\n  render: `with(this){return _c('p',{attrs:{\"id\":\"container\"}},[(flag === 'a' )?_c('span',[_v(\"A\")]):_c('span',[_v(\"B\")])])}`,\n  staticRenderFns: [],\n  errors: [],\n  tips: []\n}\n\n//AST通过render生成VNode\n\nconsole.log(res.render())\n//生成的with函数return一个 _c函数，就是createElement。执行函数体返回VNode。\n//with(this){return _c('p',{attrs:{\"id\":\"container\"}},[(flag === 'a' )?_c('span',[_v(\"A\")]):_c('span',[_v(\"B\")])])}\n")])])]),n("p",[e._v("我们通过 vue-template-compiler，可以将template转换成with函数的VNode。但是在实际开发环境中，我们通过webpack打包经过vue-loader处理之后，生成的dist文件就已经是一段段的编译好的with函数了。")]),e._v(" "),n("h2",{attrs:{id:"直接写render函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#直接写render函数"}},[e._v("#")]),e._v(" 直接写render函数")]),e._v(" "),n("p",[e._v("vue中可以通过直接写render函数，取代template。\nReact使用jsx语法糖，直接使用render，没有template。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Vue.component('Hello',{\n  render:function (createElement){\n   return createElement(\n     'h'+this.level,\n    [\n      createElement('a',{\n        attr:{\n          name:'head',\n          href:'#'\n        }\n      },'this is link')\n    ]\n   )\n  }\n})\n")])])]),n("h2",{attrs:{id:"渲染过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#渲染过程"}},[e._v("#")]),e._v(" 渲染过程")]),e._v(" "),n("ul",[n("li",[e._v("1 解析template为render函数(或在开发环境已经完成，vue-loader。正常单页webpack打包通过vue-loader，就已经变成了render函数)")]),e._v(" "),n("li",[e._v("2 触发响应式，observe的过程。")]),e._v(" "),n("li",[e._v("3 执行render函数，生成vnode，patch(elem,vnode)")])]),e._v(" "),n("h2",{attrs:{id:"更新过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#更新过程"}},[e._v("#")]),e._v(" 更新过程")]),e._v(" "),n("ul",[n("li",[e._v("修改data，触发setter")]),e._v(" "),n("li",[e._v("重新执行render函数，生成 newVnode")]),e._v(" "),n("li",[e._v("patch(VNode,newVVode)")])])])}),[],!1,null,null,null);t.default=r.exports}}]);