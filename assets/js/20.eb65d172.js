(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{226:function(n,e,s){"use strict";s.r(e);var t=s(5),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,s=n._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h1",{attrs:{id:"promise"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[n._v("#")]),n._v(" promise")]),n._v(" "),s("h2",{attrs:{id:"promise-实现思路"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-实现思路"}},[n._v("#")]),n._v(" promise 实现思路")]),n._v(" "),s("h3",{attrs:{id:"步骤一-简单版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#步骤一-简单版本"}},[n._v("#")]),n._v(" 步骤一 简单版本")]),n._v(" "),s("ul",[s("li",[n._v("new Promise 时候 让excutor执行，传如一个成功resolve方法，一个reject方法。")]),n._v(" "),s("li",[n._v("通过这两个方法改变，reason和val的值。和padding的状态。")]),n._v(" "),s("li",[n._v("padding状态只能改变一次。")])]),n._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("const PADDING = 'PADDING';\nconst RESOLVE = 'RESOLVE';\nconst REJECT = 'REJECT';\n\nclass promise{\n    constructor(executor){\n        this.status = PADDING;\n        this.val  = '';\n        this.reason = '';\n\n        let resolve = (val)=>{\n            if(this.status === PADDING){\n                this.status = RESOLVE;\n                this.val = val\n            }\n        };\n\n        let reject = (reason)=>{\n            if(this.status === PADDING){\n                this.status = REJECT;\n                this.reason = reason\n            }\n        };\n        try {\n            executor(resolve,reject)// new时调\n        }catch (e) {\n            reject(e)\n        }\n    }\n    then(onFulfilled,onRejected){\n        //同步\n        if(this.status === RESOLVE){\n            onFulfilled(this.val)\n        }\n        if(this.status === REJECT){\n            onRejected(this.reason)\n        }\n    }\n}\n")])])]),s("h2",{attrs:{id:"步骤二-发布订阅模式-异步的场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#步骤二-发布订阅模式-异步的场景"}},[n._v("#")]),n._v(" 步骤二 发布订阅模式（异步的场景）")]),n._v(" "),s("ul",[s("li",[n._v("通过setTimeOut(function(){ resolve('success') })模拟异步，此时的then方法中status状态为 padding。")]),n._v(" "),s("li",[n._v("通过发布订阅的模式，把成功的回调和失败的回调分别放在各自数组中。")])]),n._v(" "),s("div",{staticClass:"language-angular2 extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("class myPromise {\n        constructor(executor) {\n            this.status = PADDING;\n            this.val = undefined;//成功原因\n            this.reason = undefined;\n            this.onResolveCallbacks = [];//成功回调数组\n            this.onRejectcallbacks = [];//失败回调数组\n            //成功函数\n            let resolve = (val)=>{\n               if(this.status === PADDING){\n                   this.val = val;\n                   this.status = RESOLVE;\n                   this.onResolveCallbacks.forEach( fn=>{ fn() })\n               }\n            };\n            //失败函数\n            let reject = (reason)=>{\n                if(this.status === PADDING){\n                    this.reason = reason;\n                    this.status = REJECT;\n                    this.onRejectcallbacks.forEach( fn=>{ fn() })\n                }\n            };\n\n            try {\n                executor(resolve,reject); //new时候执行\n            }catch(error)\n            {\n                reject(error)\n\n            }\n        }\n    then(onFulfilled,onRejected){\n        //同步的情况\n        if(this.status === RESOLVE){\n            onFulfilled(this.val)\n        }\n        if(this.status === REJECT){\n            onFulfilled(this.reason)\n        }\n        console.log('----this.status-',this.status)\n        //异步的情况 利用发布订阅\n        if(this.status === PADDING){\n            //异步先订阅号数据\n            this.onResolveCallbacks.push(()=>{\n                onFulfilled(this.val)\n            });\n            console.log('------this.onResolveCallbacks',this.onResolveCallbacks)\n            this.onRejectcallbacks.push(()=>{\n                onRejected(this.reason)\n            });\n        }\n    }\n}\n")])])]),s("h3",{attrs:{id:"步骤三-链式调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#步骤三-链式调用"}},[n._v("#")]),n._v(" 步骤三 链式调用")]),n._v(" "),s("ul",[s("li",[s("p",[n._v("下一个回调是否调用，依赖于上一个promise的返回结果（成功或失败）。")])]),n._v(" "),s("li",[s("p",[n._v("假设如果返回underfind则也会相当于一个成功的promise。")])]),n._v(" "),s("li",[s("p",[n._v("假设如果返回throw Error则会返回失败的promise。")])]),n._v(" "),s("li",[s("p",[n._v("假设如果return new Promise(function(){})返回空的promise则可以不走成功或者失败的回调，返回一个padding的Promise.")])]),n._v(" "),s("li",[s("p",[n._v("每次执行promise都会返回一个新的promise。")])]),n._v(" "),s("li",[s("p",[n._v("根据上一个promise的返回结果x，如果x是一个promise调用then。")])]),n._v(" "),s("li",[s("p",[n._v("如果x是一个普通的值或者underfind则返回promise一个新的promise。")])])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\nconst PADDING = 'PADDING';\nconst RESOLVE = 'RESOLVE';\nconst REJECT = 'REJECT';\n\n/**\n * new Promise 时候 让excutor执行，传如一个成功resolve方法，一个reject方法。通过这两个方法改变，reason和val的值。和padding的状态。\n * 状态发生变化后不能改变。\n *\n * promise 链式回调实现方式， 发布订阅。\n */\n\nconst resolvePromise = (promise2,x,resolve,reject)=>{\n\n}\nclass myPromise {\n        constructor(executor) {\n            this.status = PADDING;\n            this.val = undefined;//成功原因\n            this.reason = undefined;\n            this.onResolveCallbacks = [];//成功回调数组\n            this.onRejectcallbacks = [];//失败回调数组\n            //成功函数\n            let resolve = (val)=>{\n               if(this.status === PADDING){\n                   this.val = val;\n                   this.status = RESOLVE;\n                   this.onResolveCallbacks.forEach( fn=>{ fn() })\n               }\n            };\n            //失败函数\n            let reject = (reason)=>{\n                if(this.status === PADDING){\n                    this.reason = reason;\n                    this.status = REJECT;\n                    this.onRejectcallbacks.forEach( fn=>{ fn() })\n                }\n            };\n\n            try {\n                executor(resolve,reject); //new时候执行\n            }catch(error)\n            {\n                reject(error)\n\n            }\n        }\n\n    /**\n     * 根据返回值判断then的处理逻辑\n     * 1 如果返回promise接着往下执行\n     * 2 如果返回成功的promise执行onFulfilled\n     * 3 如果返回失败的promise执行onRejected\n     * 4 根据上一次返回的值，判断promise2的状态\n     * @param onFulfilled\n     * @param onRejected\n     */\n    then(onFulfilled,onRejected){\n        let promise2 = new Promise(((resolve, reject) => {\n            //同步的情况\n            if(this.status === RESOLVE){\n                /**\n                 * 根据x的值 推导promise2的状态\n                 * x可能是普通值\n                 * x也可能是promise，接着调用then\n                 */\n               setTimeout(function () {\n                   let x = onFulfilled(this.val);\n                   resolvePromise(promise2,x,resolve,reject)\n               },0)\n            }\n            if(this.status === REJECT){\n                let x = onFulfilled(this.reason)\n            }\n            console.log('----this.status-',this.status)\n            //异步的情况 利用发布订阅\n            if(this.status === PADDING){\n                //异步先订阅号数据\n                this.onResolveCallbacks.push(()=>{\n                    let x = onFulfilled(this.val)\n                });\n                console.log('------this.onResolveCallbacks',this.onResolveCallbacks)\n                this.onRejectcallbacks.push(()=>{\n                    let x = onRejected(this.reason)\n                });\n            }\n        }));\n    }\n}\n\nmodule.exports = myPromise\n\n")])])]),s("h2",{attrs:{id:"promise练习题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise练习题"}},[n._v("#")]),n._v(" promise练习题")]),n._v(" "),s("ul",[s("li",[n._v("then 正常返回 resolved，里面有报错则返回 rejected。")]),n._v(" "),s("li",[n._v("catch 正常返回 resolved, 里面有报错则返回 rejected。")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("题目1\nconst p2 = Promise.resolve().then(()=>{\n    throw new Error('error') //会返回rejectred的promise，之后的回调是then\n});\n\n题目2\nconst p3 = Promise.reject('111').catch(()=>{\n    console.log('catch');// reject执行完调用catch，catch会返回一个成功的promise，之后可以调用 then\n}).then(()=>{\n    console.log('111')//\n})\n\n题目3\n//打印结果 1  2 3\nPromise.resolve().then(()=>{\n    console.log(1);\n    throw new Error('error')\n}).catch(()=>{\n    console.log(2); // catch之后会返回一个成功的promise\n}).then(()=>{\n    console.log(3);\n})\n\n")])])]),s("h2",{attrs:{id:"async-await-和-promise的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-await-和-promise的关系"}},[n._v("#")]),n._v(" async /await 和 Promise的关系")]),n._v(" "),s("ul",[s("li",[n._v("执行async函数，返回的是Promise对象")]),n._v(" "),s("li",[n._v("await 相当于 Promise的then")]),n._v(" "),s("li",[n._v("try...catch可以捕获异常,代替来Promise.catch")]),n._v(" "),s("li",[n._v("await后面的内容都是异步的内容")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("//执行aysnc函数,返回的是Promise对象\nasync function  fn1() {\n    return  100; //相当于return Promise.resolve(100);\n}\nconst res = fn1();\nres.then((val)=>{\n   console.log(val)\n});\n\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function fn2(){\n    const data = await Promise.resolve(3000)\n    console.log(data) // 可以打印出300，await相当于 Promise.then的回调\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function fn2(){\n    const data = await 3000 //相当于Promise.resolve(3000)\n    console.log(data) // 可以打印出300，await相当于 Promise.then的回调\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("//try catch 相当于 Promise的catch\n\nasync function fn3){\n    try{\n        const res = await Promise.reject('error')\n    }catch{\n        console.log(res)\n    }\n\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function fn4{\n    const res = await Promise.reject('error');\n    console.log(res);// 此时的res不会被执行，因为await相当于Promise的then，当reject 时候会执行catch不会执行then，所以此时必须要通过try catch 捕获。\n}\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function async1(){\n    console.log('fn start')\n    await async2()\n    //await后面当作异步代码来执行\n    console.log('fn end')\n}\n\nconsole.log('script start');\nasync1()\nconsole.log('script end');\n\nasync function async2(){\n    console.log('async2')\n}\n打印顺序 \nscript start\nfn start\nasync2\nscript end\nfn end\n\n")])])]),s("h3",{attrs:{id:"场景题分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#场景题分析"}},[n._v("#")]),n._v(" 场景题分析")]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("async function fn(){\n    return 100\n}\n\n(async function(){\n    const a  = fn();//a的值为 Promise.resolve(100)\n    const b  = await fn();// b的值为100，await是promise.resolve的回调\n})()    \n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("(async function(){\n    console.log('start')\n    const a = await 100\n    console.log(a) // a的值为100 \n    const b = await Promise.resolve(200)\n    console.log(b) // b的值为200\n    const c = await Promise.reject(300) //此时会报错因为c是 Promise.resolve()的回调，此时拿不到reject的值，需要使用try catch不然报错。执行不下去了\n    console.log(c) \n})()\n\n\nPromise.resolve().then(() => {\n  return new Error('error!!!')// 会返回一个成功的promise，携带这error\n }).then((res) => {\n   console.log('then: ', res) // 打印 then:  Error: error!!!\n }).catch((err) => {\n   console.log('catch: ', err)\n })\n//变换\nPromise.resolve().then(() => {\n  throw new Error('error!!!')// \n }).then((res) => {\n   console.log('then: ', res) \n }).catch((err) => {\n   console.log('catch: ', err) // 打印 catch:  Error: error!!!\n })\n\n\n\n\n\n\nconst promise = Promise.resolve().then(() => {\n   return promise \n })\npromise.catch(console.error)\n// 执行结果如下：\n// TypeError: Chaining cycle detected for promise #<Promise>\n\n// .then或 .catch返回的值不能是 promise本身，否则会造成死循环。类似于：\n\nprocess.nextTick(function tick () {\n  console.log('tick')\n  process.nextTick(tick)\n})\n\n\n")])])]),s("h2",{attrs:{id:"promise-all"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-all"}},[n._v("#")]),n._v(" promise.all()")]),n._v(" "),s("p",[n._v("Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。")]),n._v(" "),s("ul",[s("li",[n._v("处理多个promise的状态，当p1，p2都成功时，返回的是 [p1,p2].")]),n._v(" "),s("li",[n._v("当p1,p2有一个失败时候，走的是catch 方法，返回的值是第一个reject的值。")])]),n._v(" "),s("div",{staticClass:"language-angular2html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("let p1 = new Promise((resolve, reject) => {\n    resolve('成功了')\n})\n\nlet p2 = new Promise((resolve, reject) => {\n    resolve('success')\n})\n\nlet p3 = Promise.reject('失败')\n\nPromise.all([p1, p2]).then((result) => {\n    console.log(result)               //['成功了', 'success']\n}).catch((error) => {\n    console.log('err',error)\n})\n")])])]),s("h2",{attrs:{id:"promise-race"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-race"}},[n._v("#")]),n._v(" Promise.race()")]),n._v(" "),s("p",[n._v("Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。")]),n._v(" "),s("div",{staticClass:"language-angular2html extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("\n\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success')\n  },1000)\n})  \n\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject('failed')\n  }, 500)\n})\n\nPromise.race([p1, p2]).then((result) => {\n  console.log(result)\n}).catch((error) => {\n  console.log(error)  // 打开的是 'failed'\n})\n\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);