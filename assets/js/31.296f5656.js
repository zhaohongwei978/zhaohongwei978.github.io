(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{222:function(t,e,a){"use strict";a.r(e);var s=a(5),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"移动端问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动端问题"}},[t._v("#")]),t._v(" 移动端问题")]),t._v(" "),a("h2",{attrs:{id:"rem-布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rem-布局"}},[t._v("#")]),t._v(" Rem 布局")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("rem(root em)是一个相对单位，类似 em，但是 rem 基准 html 元素的字体大小。动态修改 html 文字大小改变页面中元素的大小。\n页面字体的变化可以随着视口的缩放而变化。")])]),t._v(" "),a("li",[a("p",[t._v("响应式布局的过程中，我们页面中的 rem 值是固定，如果想让页面可以根据不同的屏幕做适配。只需要让根元素的 font-size 根据不同视口宽度，发生变化。")])])]),t._v(" "),a("p",[t._v("假设 一个页面中 750 设计稿 盒子 w:100px h:100px\n在 750 设计稿中，假设根元素 html font-size 是 100px 该盒子的宽高是 1rem.盒子实际大小是 100px。\n若在 640 的屏幕中，盒子的根元素 html font-size: (640/750)*100px")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("视口宽度")]),t._v(" "),a("th",[t._v("html 的 fontSize 大小")]),t._v(" "),a("th",[t._v("在页面中的 rem 值")]),t._v(" "),a("th",[t._v("盒子实际大小")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("750")]),t._v(" "),a("td",[t._v("100px")]),t._v(" "),a("td",[t._v("1rem")]),t._v(" "),a("td",[t._v("1rem * 100px = 100px")])]),t._v(" "),a("tr",[a("td",[t._v("640")]),t._v(" "),a("td",[t._v("(640/750) *100px = 85.33px")]),t._v(" "),a("td",[t._v("1rem")]),t._v(" "),a("td",[t._v("1rem * 85.3px = 85.3px")])])])]),t._v(" "),a("h3",{attrs:{id:"rem-的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rem-的实现"}},[t._v("#")]),t._v(" REM 的实现")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('window.onresize = function(){\n    getRem(750,100)\n}\nfunction getRem(pageWidth,remValue){\n    var html = document.getElementsByTagName("html")[0];\n    currentWidth = document.body.clientWidth;\n    html.style.fontSize = (currentWidth/pageWidth)*remValue + "px";\n}\n')])])]),a("h3",{attrs:{id:"em-根据相邻父元素计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#em-根据相邻父元素计算"}},[t._v("#")]),t._v(" em 根据相邻父元素计算")]),t._v(" "),a("p",[t._v("em 是父元素的字体大小变化而变化。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('em 根据父元素font-size计算\n<div style="font-size:10px">\n    <p style="width:20em;height:20em;backgournd:red"> // 盒子实际是 宽高 200px\n</div>\n\n')])])]),a("h3",{attrs:{id:"media-根据屏幕范围切换引入资源"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#media-根据屏幕范围切换引入资源"}},[t._v("#")]),t._v(" @media 根据屏幕范围切换引入资源")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<link ref="stylesheet" href="style320.css" media="screen and (min-width:320px)">\n<link ref="stylesheet" href="style640.css" media="screen and (min-width:640px)">\n')])])]),a("h2",{attrs:{id:"ios-平滑滚动问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios-平滑滚动问题"}},[t._v("#")]),t._v(" ios 平滑滚动问题")]),t._v(" "),a("p",[t._v("原因：在 iOS 5.0 以及之后的版本，滑动有定义有两个值 auto 和 touch，默认值为 auto。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */\n\n-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */\n")])])]),a("h2",{attrs:{id:"移动端设置滚动条隐藏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动端设置滚动条隐藏"}},[t._v("#")]),t._v(" 移动端设置滚动条隐藏")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(".container ::-webkit-scrollbar {display: none;}\n\n")])])]),a("h2",{attrs:{id:"弹出层事件穿透问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#弹出层事件穿透问题"}},[t._v("#")]),t._v(" 弹出层事件穿透问题")]),t._v(" "),a("p",[t._v("思路：js 打开弹框给根元素增加 overfow:hidden\njs 关闭弹框去掉 overfow:hidden")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/**\n    * 禁止穿透\n    **/\nstopScroll(){\n    let _scrollTop = document.scrollingElement.scrollTop;\n    this.scrollTop = _scrollTop;\n    document.body.style.overflow='hidden';\n    document.body.style.top = -_scrollTop + 'px';\n},\n/**\n    * 取消滑动限制\n    **/\ncanScroll(){\n    document.body.style.overflow='auto';\n    document.scrollingElement.scrollTop = this.scrollTop;\n},\n")])])]),a("h2",{attrs:{id:"ios-上拉边界下拉出现白色空白"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ios-上拉边界下拉出现白色空白"}},[t._v("#")]),t._v(" iOS 上拉边界下拉出现白色空白")]),t._v(" "),a("p",[t._v("手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。")]),t._v(" "),a("p",[t._v("原因：手指按住屏幕上下拖动，会触发 touchmove 事件。这个事件触发的对象是整个 webview 容器，容器自然会被拖动，剩下的部分会成空白。")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("touchstart ：手指放在一个 DOM 元素上。")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("touchmove ：手指拖曳一个 DOM 元素。")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[t._v("touchend ：手指从一个 DOM 元素上移开。")])])])]),t._v(" "),a("h2",{attrs:{id:"输入键盘遮挡问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#输入键盘遮挡问题"}},[t._v("#")]),t._v(" 输入键盘遮挡问题")]),t._v(" "),a("h2",{attrs:{id:"浏览器小于-12px-字体问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器小于-12px-字体问题"}},[t._v("#")]),t._v(" 浏览器小于 12px 字体问题")]),t._v(" "),a("p",[t._v("浏览器默认字体最小 12px，\n因为浏览器默认最小字体 12px，当小于 12px 的字体，浏览器会当作 12px 来处理。如果设计为 10px 应该如何来解决呢。\n通过 tranform:scale()缩放。tranform 缩放是视觉缩放，不会改变页面的排版位置。只会在盒子的可视范围内缩放。所以 tranform 不会带来重排问题，只会重绘。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<div style="font-size: 20px;">20px</div>\n<div style="font-size: 12px;">12px</div>视觉上看到的是12px\n<div style="font-size: 10px;">10px</div>视觉上看到的仍然是12px\n')])])]),a("h2",{attrs:{id:"移动端-1px-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#移动端-1px-问题"}},[t._v("#")]),t._v(" 移动端 1px 问题")])])}),[],!1,null,null,null);e.default=r.exports}}]);