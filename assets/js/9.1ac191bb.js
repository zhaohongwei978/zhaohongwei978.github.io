(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{185:function(t,n,o){t.exports=o.p+"assets/img/WX20201118-201742@2x.cc047fa1.png"},230:function(t,n,o){"use strict";o.r(n);var a=o(5),e=Object(a.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),a("p",[a("img",{attrs:{src:o(185),alt:"WX20201118-201742@2x.png"}})]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Cat (name) {\n    this.name = name;\n}\n\nCat.prototype.color = 'white';\n\nvar cat1 = new Cat('Tom');\nconsole.log(cat1)//{name:'tom'}\nvar cat2 = new Cat('Mark');\nconsole.log(cat2)//{name:'Mark'}\ncat1.color = 'black';\nconsole.log(cat1,cat2)//{name:'tom',color:'black'}{name:'tom'}\nconsole.log(cat1.color)//black\nconsole.log(Cat.color)//函数无法直接获取属性\n")])])]),a("h2",{attrs:{id:"什么是原型链"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型链"}},[t._v("#")]),t._v(" 什么是原型链？")]),t._v(" "),a("p",[t._v("访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 proto 这条链向上找，这条链便是原型链。")]),t._v(" "),a("p",[t._v("原型链解决的问题，多个实例共享属性方法的问题，减少开辟内存空间。")]),t._v(" "),a("h2",{attrs:{id:"【proto】与-prototype-显式原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#【proto】与-prototype-显式原型"}},[t._v("#")]),t._v(" 【"),a("em",[t._v("proto")]),t._v("】与 prototype（显式原型）")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("所有对象都有【"),a("em",[t._v("proto")]),t._v("】隐式原型,而只有函数对象才有 prototype。")])]),t._v(" "),a("li",[a("p",[t._v("函数是一个特殊的对象，当一个函数被创建后，这个函数会附带一个属性 prototype，prototype 代表函数的原型。")])]),t._v(" "),a("li",[a("p",[t._v("prototype 对象有两个属性，constructor 和 【"),a("em",[t._v("proto")]),t._v("】。")])]),t._v(" "),a("li",[a("p",[t._v("constructor 这个属性指创建原型的函数，它指向函数本身，而【"),a("em",[t._v("proto")]),t._v("】指向原型对象。")])])]),t._v(" "),a("h2",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),a("p",[t._v("NothingSpecial 只是一个普通的函数.当使用 new 调用时，就会构造一个对象并赋值给 a,此时 NothingSpecial(){}是构造函数。但 NothingSpecial 本身并不是构造函数。")]),t._v(" "),a("div",{staticClass:"language-$xslt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Foo() {\n  }\n  let a = new Foo(); // true\n  console.log(a);\n")])])]),a("ul",[a("li",[t._v("Foo.prototype.constructor == a.constructor == a["),a("strong",[t._v("proto")]),t._v("]constructor == Foo")])]),t._v(" "),a("div",{staticClass:"language-$xslt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('function NothingSpecial() { console.log( "Don\'t mind me!" );\n}\nvar a = new NothingSpecial();\n// "Don\'t mind me!" a; // {}\n\n')])])]),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var F = function(){};\nObject.prototype.a = function(){};\nFunction.prototype.b = function(){};\nvar f = new F();\n// f 能取到a,b吗？原理是什么？\n\nf.__proto__ === F.prototype  ===> F.prototype__proto__ === Object.prototype ===> Object.prototype.__proto__ === null\n所以 f可以找到a\n\nF.__proto__ === Function.prototype ===> Function.prototype.__proto === Object.prototype ===> Object.prototype.__proto__ === null \n所以F既能找到b也能找到a\n\n")])])]),a("h2",{attrs:{id:"函数对象-vs-普通对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数对象-vs-普通对象"}},[t._v("#")]),t._v(" 函数对象 vs 普通对象")]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//普通对象\nvar o1 = {}; \nvar o2 =new Object();\nvar o3 = new f1();\n\nconsole.log(typeof o1); //object \nconsole.log(typeof o2); //object \nconsole.log(typeof o3); //object\n\n//函数对象\n\n- f1 f2实际上都是通过new Function创建的函数对象\n\nfunction f1(){}; \nvar f2 = function(){};\nvar f3 = new Function('str','console.log(str)');\n\nconsole.log(typeof f1); //function \nconsole.log(typeof f2); //function \nconsole.log(typeof f3); //function   \n")])])]),a("ul",[a("li",[t._v("所有函数对象的proto都指向Function.prototype，它是一个空函数（Empty function）")])]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身\n\nNumber.__proto__ === Function.prototype  // true\nNumber.constructor == Function //true\n\nString.__proto__ === Function.prototype  // true\nString.constructor == Function //true\n\nObject.__proto__ === Function.prototype  // true\nObject.constructor == Function // true\n\n\nRegExp.__proto__ === Function.prototype  // true\nRegExp.constructor == Function //true\n\nError.__proto__ === Function.prototype   // true\nError.constructor == Function //true\n\nDate.__proto__ === Function.prototype    // true\nDate.constructor == Function //true\n")])])]),a("h2",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),a("h3",{attrs:{id:"原型链继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原型链继承"}},[t._v("#")]),t._v(" 原型链继承")]),t._v(" "),a("p",[t._v("将父类的实例，作为子类的原型")]),t._v(" "),a("ul",[a("li",[t._v("即把父类的实例，赋在了Animal的prototype上，（如果Animal.prototype上之前存在属性和方法会被覆盖）")]),t._v(" "),a("li",[t._v("该继承方法，会让子类继承父类的方法和属性。")])]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Animal() {\n    this.name = 'Animal'\n    this.toEat= function () {\n        console.log('Animal to Eat')\n    }\n}\nAnimal.prototype.toPlay = function(){\n    console.log('Animal to Play')\n}\n\nfunction Dog() {\n    this.name = 'dog'\n}\n\nDog.prototype.toGo = function(){\n    console.log('to Go')\n}\n\nDog.prototype =new Animal()\n\nlet dog = new Dog();\nconsole.log(dog)//{name: \"dog\",__proto__: Animal}\n\n//dog.__proto__ === Animal.prototype\nconsole.log(dog.__proto__)\n//dog.__proto__  {name: \"Animal\",toEat:fn,__proto__: Object}\n\n//dog.__proto__ == Dog.prototype\n//Dog.prototype == Animal.prototype\nconsole.log(dog.__proto__.__proto__)\n//dog.__proto__.__proto__  {toPlay: fn,__proto__: Object}\n")])])]),a("h3",{attrs:{id:"构造继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造继承"}},[t._v("#")]),t._v(" 构造继承")]),t._v(" "),a("ul",[a("li",[t._v("使用父类的构造函数，来增强子类的实例,这种扩展方式，cat是不能够继承Animal.prototype")]),t._v(" "),a("li",[t._v("但是构造继承可以实现多继承")]),t._v(" "),a("li",[t._v("创建子类的时候可以向父类传参")])]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Cat (){\n    Animal.call(this)\n}\n\nlet cat = new Cat();\n\n\nconsole.log(cat)// { name:'Animal',toEat:fn,__proto__:Cat }\n\nconsole.log(cat.__proto__) // { __proto__ : Object }\n\n//cat.__proto__ === Cat.prototype\nconsole.log(cat.__proto__.__proto__)//指向了Object\n\n\nconsole.log(cat instanceof Cat ) //true\nconsole.log(cat instanceof Animal) //false\nconsole.log(cat instanceof Type) // false\n\n")])])]),a("p",[t._v("构造继承实现多继承")]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Type (){\n    this.type = '111\n}\n\nfunction Cat (){\n    Type.call(this)\n    Animal.call(this)\n}\n")])])]),a("h3",{attrs:{id:"组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组合继承"}},[t._v("#")]),t._v(" 组合继承")]),t._v(" "),a("p",[t._v("组合继承 = 构造继承 + 原型继承。")]),t._v(" "),a("p",[t._v("原型链继承 实现对原型属性和方法的继承，用借用构造函数继承来实现对实例属性的继承。")]),t._v(" "),a("ul",[a("li",[t._v("优点 弥补了构造继承和原型继承的缺点，也可以实现多继承，也可以传参。")]),t._v(" "),a("li",[t._v("缺点 1构造函数被实例化了两次。2创建的实例和原型上存在两份相同的属性;")])]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Pig(){\n    Animal.call(this,'兔子')\n}\nPig.prototype = new Animal();\nPig.prototype.constructor = Pig;  //将 Pig 原型对象的 constructor 指针重新指向 Pig 本身\n\nlet pig = new Pig();\nconsole.log(pig)\n")])])]),a("h3",{attrs:{id:"寄生组合继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#寄生组合继承"}},[t._v("#")]),t._v(" 寄生组合继承")]),t._v(" "),a("p",[t._v("在组合继承的基础上进行优化，减少了实例被初始化了两次和sun 和 father上出现相同的属性")]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Father() {\n    this.name = 'father'\n}\n\nFather.prototype.toPlay= function () {\n    console.log('to play')\n}\nfunction Sun() {\n    Father.call(this)\n}\n\nSun.prototype.toGo= function () {\n    console.log('to Go')\n}\n\nlet c = Object.create(Father.prototype)\n\nSun.prototype = Object.create(Father.prototype)\nSun.prototype.constructor = Sun\n\n")])])]),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Duck(){\n    Animal.call(this);\n}\n\n(function(){\n    //创建一个新的实例\n    let S = function(){};\n    S.prototype = Animal.prototype;\n    Dog.prototype = new S();\n})();\n\nlet duck  = new Duck();\n\n")])])]),a("h3",{attrs:{id:"class-继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#class-继承"}},[t._v("#")]),t._v(" Class 继承")]),t._v(" "),a("ul",[a("li",[t._v("ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上（Father.apply(this)）")]),t._v(" "),a("li",[t._v("ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法）,然后再用子类的构造函数修改this；\n如果子类没有定义constructor方法，这个方法会默认添加，也就是说，不管有没有显式定义，任何一个子类都有constructor方法。")]),t._v(" "),a("li",[t._v("在子类的构造函数中，只有调用super之后，才能使用this关键字，否则会报错")])]),t._v(" "),a("div",{staticClass:"language-angular2html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Son extends Father {\n}\n\n//等同于\nclass Son extends Parent {\n      constructor(...args) {\n      super(...args);\n     }\n}\n")])])])])}),[],!1,null,null,null);n.default=e.exports}}]);