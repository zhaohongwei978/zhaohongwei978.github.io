(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{269:function(e,n,t){"use strict";t.r(n);var o=t(5),r=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue-实例挂载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-实例挂载"}},[e._v("#")]),e._v(" vue 实例挂载")]),e._v(" "),t("h2",{attrs:{id:"获取-render"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#获取-render"}},[e._v("#")]),e._v(" 获取 render")]),e._v(" "),t("p",[e._v("思路：vue 只认 render 函数，如果存在 render 函数直接使用，如果 render 函数不存在，找到 template 把 template 编译成 render 函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//缓存了原型上的 $mount 方法\nconst mount = Vue.prototype.$mount\n//重新定义mount方法\nVue.prototype.$mount = function (\n el?: string | Element,\n hydrating?: boolean\n): Component {\n el = el && query(el)\n//vue不能直接挂在body或者html上\n /* istanbul ignore if */\n if (el === document.body || el === document.documentElement) {\n   process.env.NODE_ENV !== 'production' && warn(\n     `Do not mount Vue to <html> or <body> - mount to normal elements instead.`\n   )\n   return this\n }\n\n const options = this.$options\n // resolve template/el and convert to render function\n //如果没有定义render方法\n if (!options.render) {\n   //获取到template字符串\n   let template = options.template\n   if (template) {\n     if (typeof template === 'string') {\n       if (template.charAt(0) === '#') {\n         template = idToTemplate(template)\n         /* istanbul ignore if */\n         if (process.env.NODE_ENV !== 'production' && !template) {\n           warn(\n             `Template element not found or is empty: ${options.template}`,\n             this\n           )\n         }\n       }\n     } else if (template.nodeType) {\n       template = template.innerHTML\n     } else {\n       if (process.env.NODE_ENV !== 'production') {\n         warn('invalid template option:' + template, this)\n       }\n       return this\n     }\n   } else if (el) {\n     template = getOuterHTML(el)\n   }\n   if (template) {\n     /* istanbul ignore if */\n     if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n       mark('compile')\n     }\n    //compileToFunctions 把template转化为render方法\n     const { render, staticRenderFns } = compileToFunctions(template, {\n       shouldDecodeNewlines,\n       shouldDecodeNewlinesForHref,\n       delimiters: options.delimiters,\n       comments: options.comments\n     }, this)\n     options.render = render\n     options.staticRenderFns = staticRenderFns\n\n     /* istanbul ignore if */\n     if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n       mark('compile end')\n       measure(`vue ${this._name} compile`, 'compile', 'compile end')\n     }\n   }\n }\n //调用原型本身的mount挂载方法\n return mount.call(this, el, hydrating)\n}\n")])])]),t("h2",{attrs:{id:"mount-把-render-函数挂载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mount-把-render-函数挂载"}},[e._v("#")]),e._v(" $mount 把 render 函数挂载")]),e._v(" "),t("p",[e._v("$mount  方法支持传入 2 个参数，")]),e._v(" "),t("ul",[t("li",[e._v("第一个是  el，它表示挂载的元素，可以是字符串，也可以是 DOM 对象，如果是字符串在浏览器环境下会调用  query  方法转换成 DOM 对象的。")]),e._v(" "),t("li",[e._v("第二个参数是和服务端渲染相关，在浏览器环境下我们不需要传第二个参数。")])]),e._v(" "),t("p",[e._v("$mount 方法实际上会去调用 「mountComponent」 方法（完成整个渲染过程）")]),e._v(" "),t("p",[e._v("mountComponent 核心就是先调用 vm._render 方法先生成虚拟 Node，再实例化一个渲染 Watcher，在它的回调函数中会调用 updateComponent 方法，最终调用 vm._update 更新 DOM。Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数，另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数，这块儿我们会在之后的章节中介绍。函数最后判断为根节点的时候设置 vm._isMounted 为 true，表示这个实例已经挂载了，同时执行 mounted 钩子函数。这里注意 vm.$vnode 表示 Vue 实例的父虚拟 Node，所以它为 Null 则表示当前是根 Vue 的实例。")])])}),[],!1,null,null,null);n.default=r.exports}}]);