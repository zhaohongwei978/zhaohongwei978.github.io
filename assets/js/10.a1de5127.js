(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{188:function(t,e,s){t.exports=s.p+"assets/img/1599408879599.efe5515c.jpg"},235:function(t,e,s){"use strict";s.r(e);var a=s(5),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),a("h2",{attrs:{id:"event-loop是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop是什么"}},[t._v("#")]),t._v(" event-loop是什么？")]),t._v(" "),a("p",[t._v("js是单线程，异步是基于回调实现的，Event-loop是异步回调的实现原理。")]),t._v(" "),a("h2",{attrs:{id:"事件循环的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环的过程"}},[t._v("#")]),t._v(" 事件循环的过程")]),t._v(" "),a("p",[a("img",{attrs:{src:s(188),alt:"1599408879599.jpg"}})]),t._v(" "),a("div",{staticClass:"language-$xslt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("console.log('111')\nsetTimeOut(function){ console.log('333') },1000)\nconsole.log('222')\n")])])]),a("ul",[a("li",[a("p",[t._v("同步代码一行行执行放在Call Stack中")])]),t._v(" "),a("li",[a("p",[t._v("如果遇到异步，会先记录。时机到了把回调函数放在 callback queue中。\n（遇到setTimeOut，是浏览器的API，在webAPI中设置定时器，到达定时器时间把回调函数放入callback queue中）")])]),t._v(" "),a("li",[a("p",[t._v("如果 Call Stack为空（同步代码执行完）Event-loop开始工作")])]),t._v(" "),a("li",[a("p",[t._v("轮询查找 callback queue，如果有则移动到 call statck中执行")])]),t._v(" "),a("li",[a("p",[t._v("然后继续轮询查找")])])]),t._v(" "),a("h2",{attrs:{id:"dom事件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dom事件"}},[t._v("#")]),t._v(" DOM事件")]),t._v(" "),a("p",[t._v("DOM事件，js执行到DOM事件如click,事件是WebAPI，当用户点击时，把回调函数挂到callback Queue中(但DOM事件不是异步，只是通过Event-loop来实现。)")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://www.ruanyifeng.com/blogimg/asset/2014/bg2014100802.png",alt:"QQ截图20200203155301.png"}})]),t._v(" "),a("h2",{attrs:{id:"为什么javascript是单线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么javascript是单线程"}},[t._v("#")]),t._v(" 为什么JavaScript是单线程？")]),t._v(" "),a("p",[t._v("作为浏览器的脚本语言，js主要用途是和用户交互和操作DOM。（如果js一个线程操作DOM，一个线程删除DOM。会带来同步的问题）")]),t._v(" "),a("p",[t._v("为了利用多核计算能力,HTML5提出Web Woker标准允许js创建多线程，但是子进程完全受控于主线程，且不得操作DOM，（并没有改变js单线程的本质）")]),t._v(" "),a("h2",{attrs:{id:"任务队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[t._v("#")]),t._v(" 任务队列")]),t._v(" "),a("p",[t._v("主线程：主线程上执行所有的同步任务，主线成的这些同步任务形成一个执行栈。\n任务队列：任务队列是一个事件的队列，")]),t._v(" "),a("p",[t._v("（所有的事件都是通过回调实现，都是需要放在异步队列中执行（需要指定回调函数，等待主线程清空队列读取异步队列内容），setTimeOut也是在异步队列中执行，可以通过setTimeOut来模拟异步。）")]),t._v(" "),a("h2",{attrs:{id:"settimeout-fn-0-的含义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settimeout-fn-0-的含义"}},[t._v("#")]),t._v(" setTimeOut(fn,0)的含义")]),t._v(" "),a("p",[t._v('setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。\nHTML5 setTimeout第二个参数最小值不能低于4ms，对于DOM的变动（涉及页面重新渲染的那部分），通常不会立即执行，而是每16ms执行一次。\n所以此时使用requestAnimationFrame（）的效果要好于setTimeOut（）.\nsetTimeOut()只是把事件插入到任务队列中，必须等到当前代码主线程执行栈执行完，和异步队列现有任务都执行完，才会执行setTimeOut。')]),t._v(" "),a("h2",{attrs:{id:"node-js的事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node-js的事件循环"}},[t._v("#")]),t._v(" Node.js的事件循环")]),t._v(" "),a("h3",{attrs:{id:"process-nexttick方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick方法"}},[t._v("#")]),t._v(" process.nextTick方法")]),t._v(" "),a("p",[t._v('在当前"执行栈"的尾部----下一次Event Loop（主线程读取"任务队列"）之前----触发回调函数。指定的任务总是发生在所有异步任务之前。')]),t._v(" "),a("div",{staticClass:"language-$xslt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    `process.nextTick(function A() {\n      console.log(1);\n      process.nextTick(function B(){console.log(2);});\n    });\n    \n    setTimeout(function timeout() {\n      console.log('TIMEOUT FIRED');\n    }, 0)\n    // 1\n    // 2\n    // TIMEOUT FIRED`\n")])])]),a("h3",{attrs:{id:"setimmediate-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setimmediate-方法"}},[t._v("#")]),t._v(" setImmediate()方法")]),t._v(" "),a("p",[t._v('在当前"任务队列"的尾部添加事件，也就是说，它指定的任务总是在下一次Event Loop时执行，这与setTimeout(fn, 0)很像。')]),t._v(" "),a("div",{staticClass:"language-$xslt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("setImmediate(function A() {\n  console.log(1);\n  setImmediate(function B(){console.log(2);});\n});\n\nsetTimeout(function timeout() {\n  console.log('TIMEOUT FIRED');\n}, 0);\n")])])]),a("p",[t._v("setImmediate与setTimeout(fn,0)各自添加了一个回调函数A和timeout，都是在下一次Event Loop触发。那么，哪个回调函数先执行呢？答案是不确定。运行结果可能是1--TIMEOUT FIRED--2，也可能是TIMEOUT FIRED--1--2。")]),t._v(" "),a("h3",{attrs:{id:"宏任务和微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),a("ul",[a("li",[t._v("宏任务： setTimeOut setInterval Ajax DOM事件")]),t._v(" "),a("li",[t._v("微任务： Promise Async/await")]),t._v(" "),a("li",[t._v("宏任务在DOM渲染后触发，如setTimeOut")]),t._v(" "),a("li",[t._v("微任务在DOM渲染前面触发")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//现象 利用alert可以阻塞DOM渲染，观察现象\n先打印11，此时DOM还没有渲染。\n在打印222，此时页面上已经显示三个插入的p标签\nconst p1 = $('<p>111</p>')\nconst p2 = $('<p>222</p>')\nconst p3 = $('<p>333</p>')\n('#container').append('p1').append('p2').append('p3')\n\nPromise.resolve().then(()=>{\n  $('#container').children().length //打印3\n  alert('11')//打印111 \n})\n\nsetTimeOut(()=>{\n  console.log('222')\n})\n")])])]),a("h2",{attrs:{id:"在事件机制中宏任务-微任务执行的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在事件机制中宏任务-微任务执行的过程"}},[t._v("#")]),t._v(" 在事件机制中宏任务，微任务执行的过程")]),t._v(" "),a("ul",[a("li",[t._v("1 callStack清空 同步代码执行完")]),t._v(" "),a("li",[t._v("2 执行微任务队列 micro task queue")]),t._v(" "),a("li",[t._v("3 尝试DOM渲染")]),t._v(" "),a("li",[t._v("4 触发Event-loop")]),t._v(" "),a("li",[t._v("5 callbackQueue异步队列事件执行， 宏任务")])])])}),[],!1,null,null,null);e.default=n.exports}}]);