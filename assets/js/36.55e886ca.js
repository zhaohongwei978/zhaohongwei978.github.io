(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{225:function(t,e,a){"use strict";a.r(e);var v=a(5),i=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("p",[t._v("树diff的时间复杂度 o(n的三次3)\n过程 1遍历tree1，第二遍历tree2 第三排序，这三个循环一组合就是 o(n的三次3)")]),t._v(" "),a("p",[t._v("优化时间复杂度到(O(n))")]),t._v(" "),a("ul",[a("li",[t._v("只同级比较，不跨级比较")]),t._v(" "),a("li",[t._v("tag不相同，直接删掉重建，不再深度比较")]),t._v(" "),a("li",[t._v("tag和key，两者都相同，则认为是相同节点，不再深度比较")])]),t._v(" "),a("h2",{attrs:{id:"diff算法-比较策略-深度优先-同层比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#diff算法-比较策略-深度优先-同层比较"}},[t._v("#")]),t._v(" Diff算法 比较策略 深度优先，同层比较")]),t._v(" "),a("p",[t._v("snabbdom")]),t._v(" "),a("ul",[a("li",[t._v("相同的vnode，（key 和 tag都相同）patch对比，不同的vnode 销毁重建")])]),t._v(" "),a("h2",{attrs:{id:"如何理解vue中的diff算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何理解vue中的diff算法"}},[t._v("#")]),t._v(" 如何理解vue中的Diff算法？")]),t._v(" "),a("ul",[a("li",[t._v("diff算法是虚拟DOM技术的必然产物，通过新旧虚拟DOm的对比（既Diff）将变化的地方更新在真实DOM上，另外也需要Diff高效的执行对比过程，从而降低时间复杂度O(n).")]),t._v(" "),a("li",[t._v("vue2.x为了降低watcher的颗粒度，每个组件只有一个watcher，引入Diff可以精准找到DOM变化的地方。")]),t._v(" "),a("li",[t._v("vue中diff执行时候组件实例执行更新函数时。它会对比上一次渲染结果oldNode和新的渲染结果newNode。此过程称为patch。")]),t._v(" "),a("li",[t._v("diff过程深度优先，同层比较。两个节点之间会根据他们是否拥有子节点或者文本节点做不同操作。比较两组子节点是算法的重点。假设头尾节点可能相同做4次比对尝试。如果   没有找到相同节点才按照通用方式遍历查找。查找结束在按情况处理剩下节点，借助key通常可以精准的找到相同节点，因此整个patch过程很高效。")])])])}),[],!1,null,null,null);e.default=i.exports}}]);