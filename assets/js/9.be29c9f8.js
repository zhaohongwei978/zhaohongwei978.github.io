(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{185:function(t,o,a){t.exports=a.p+"assets/img/WX20201118-201742@2x.cc047fa1.png"},227:function(t,o,a){"use strict";a.r(o);var n=a(5),e=Object(n.a)({},(function(){var t=this,o=t.$createElement,n=t._self._c||o;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"原型链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),n("p",[n("img",{attrs:{src:a(185),alt:"WX20201118-201742@2x.png"}})]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Cat (name) {\n    this.name = name;\n}\n\nCat.prototype.color = 'white';\n\nvar cat1 = new Cat('Tom');\nconsole.log(cat1)//{name:'tom'}\nvar cat2 = new Cat('Mark');\nconsole.log(cat2)//{name:'Mark'}\ncat1.color = 'black';\nconsole.log(cat1,cat2)//{name:'tom',color:'black'}{name:'tom'}\nconsole.log(cat1.color)//black\nconsole.log(Cat.color)//函数无法直接获取属性\n")])])]),n("h2",{attrs:{id:"什么是原型链"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型链"}},[t._v("#")]),t._v(" 什么是原型链？")]),t._v(" "),n("p",[t._v("访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 proto 这条链向上找，这条链便是原型链。")]),t._v(" "),n("p",[t._v("原型链解决的问题，多个实例共享属性方法的问题，减少开辟内存空间。")]),t._v(" "),n("h2",{attrs:{id:"【proto】与-prototype-显式原型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#【proto】与-prototype-显式原型"}},[t._v("#")]),t._v(" 【"),n("em",[t._v("proto")]),t._v("】与 prototype（显式原型）")]),t._v(" "),n("ul",[n("li",[n("p",[t._v("所有对象都有【"),n("em",[t._v("proto")]),t._v("】隐式原型,而只有函数对象才有 prototype。")])]),t._v(" "),n("li",[n("p",[t._v("函数是一个特殊的对象，当一个函数被创建后，这个函数会附带一个属性 prototype，prototype 代表函数的原型。")])]),t._v(" "),n("li",[n("p",[t._v("prototype 对象有两个属性，constructor 和 【"),n("em",[t._v("proto")]),t._v("】。")])]),t._v(" "),n("li",[n("p",[t._v("constructor 这个属性指创建原型的函数，它指向函数本身，而【"),n("em",[t._v("proto")]),t._v("】指向原型对象。")])])]),t._v(" "),n("h2",{attrs:{id:"constructor"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),n("p",[t._v("NothingSpecial 只是一个普通的函数.当使用 new 调用时，就会构造一个对象并赋值给 a,此时 NothingSpecial(){}是构造函数。但 NothingSpecial 本身并不是构造函数。")]),t._v(" "),n("div",{staticClass:"language-$xslt extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Foo() {\n  }\n  let a = new Foo(); // true\n  console.log(a);\n")])])]),n("ul",[n("li",[t._v("Foo.prototype.constructor == a.constructor == a["),n("strong",[t._v("proto")]),t._v("]constructor == Foo")])]),t._v(" "),n("div",{staticClass:"language-$xslt extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function NothingSpecial() { console.log( "Don\'t mind me!" );\n}\nvar a = new NothingSpecial();\n// "Don\'t mind me!" a; // {}\n\n')])])])])}),[],!1,null,null,null);o.default=e.exports}}]);