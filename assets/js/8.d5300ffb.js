(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{185:function(t,a,o){t.exports=o.p+"assets/img/WX20201118-201742@2x.cc047fa1.png"},223:function(t,a,o){"use strict";o.r(a);var e=o(5),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),e("p",[e("img",{attrs:{src:o(185),alt:"WX20201118-201742@2x.png"}})]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Cat (name) {\n    this.name = name;\n}\n\nCat.prototype.color = 'white';\n\nvar cat1 = new Cat('Tom');\nconsole.log(cat1)//{name:'tom'}\nvar cat2 = new Cat('Mark');\nconsole.log(cat2)//{name:'Mark'}\ncat1.color = 'black';\nconsole.log(cat1,cat2)//{name:'tom',color:'black'}{name:'tom'}\nconsole.log(cat1.color)//black\nconsole.log(Cat.color)//函数无法直接获取属性\n")])])]),e("h2",{attrs:{id:"什么是原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是原型链"}},[t._v("#")]),t._v(" 什么是原型链？")]),t._v(" "),e("p",[t._v("访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着 proto 这条链向上找，这条链便是原型链。")]),t._v(" "),e("p",[t._v("原型链解决的问题，多个实例共享属性方法的问题，减少开辟内存空间。")]),t._v(" "),e("h2",{attrs:{id:"【proto】与-prototype-显式原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#【proto】与-prototype-显式原型"}},[t._v("#")]),t._v(" 【"),e("em",[t._v("proto")]),t._v("】与 prototype（显式原型）")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("所有对象都有【"),e("em",[t._v("proto")]),t._v("】隐式原型,而只有函数对象才有 prototype。")])]),t._v(" "),e("li",[e("p",[t._v("函数是一个特殊的对象，当一个函数被创建后，这个函数会附带一个属性 prototype，prototype 代表函数的原型。")])]),t._v(" "),e("li",[e("p",[t._v("prototype 对象有两个属性，constructor 和 【"),e("em",[t._v("proto")]),t._v("】。")])]),t._v(" "),e("li",[e("p",[t._v("constructor 这个属性指创建原型的函数，它指向函数本身，而【"),e("em",[t._v("proto")]),t._v("】指向原型对象。")])])]),t._v(" "),e("h2",{attrs:{id:"object-create"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#object-create"}},[t._v("#")]),t._v(" Object.create")]),t._v(" "),e("p",[t._v("Object.create 创建一个 对象并把这个对象的 [[Prototype]] 关联到指定的对象。")]),t._v(" "),e("div",{staticClass:"language-$xslt extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var anotherObject = { a:2};\n// 创建一个关联到 anotherObject 的对象\nvar myObject = Object.create( anotherObject );\nmyObject.a; // 2 实际上就是把a:2 挂载到了myObject上\n")])])]),e("h2",{attrs:{id:"constructor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#constructor"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),e("p",[t._v("NothingSpecial 只是一个普通的函数.当使用 new 调用时，就会构造一个对象并赋值给 a,此时 NothingSpecial(){}是构造函数。但 NothingSpecial 本身并不是构造函数。")]),t._v(" "),e("div",{staticClass:"language-$xslt extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Foo() {\n  }\n  let a = new Foo(); // true\n  console.log(a);\n")])])]),e("ul",[e("li",[t._v("Foo.prototype.constructor == a.constructor == a["),e("strong",[t._v("proto")]),t._v("]constructor == Foo")])]),t._v(" "),e("div",{staticClass:"language-$xslt extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('function NothingSpecial() { console.log( "Don\'t mind me!" );\n}\nvar a = new NothingSpecial();\n// "Don\'t mind me!" a; // {}\n\n')])])])])}),[],!1,null,null,null);a.default=r.exports}}]);