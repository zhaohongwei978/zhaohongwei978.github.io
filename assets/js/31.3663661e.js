(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{220:function(e,n,t){"use strict";t.r(n);var r=t(5),a=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"响应式observe过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#响应式observe过程"}},[e._v("#")]),e._v(" 响应式observe过程")]),e._v(" "),t("h2",{attrs:{id:"对象侦测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象侦测"}},[e._v("#")]),e._v(" 对象侦测")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    function observer(target){\n        if(typeof target !== 'object' || target === null){\n            return;\n        }\n        for(key in target){\n            defineReactive(target,key,target[key])\n            console.log(key)\n        }\n    }\n    function defineReactive (target,key,val){\n        //递归调用\n        observer(target[key])\n        Object.defineProperty(target,key,{\n            get() {\n                console.log('get');\n                return value;\n            },\n            set:function (newValue) {\n                console.log('set');\n                if(newValue !== value){\n                    target[key] = newValue;\n                }\n            }\n        })\n    }\n    let json = {\n        name:'kira',\n        age:30,\n        address:{\n            text1:{\n                des1:1,\n                des2:3\n            },\n            text2:2\n        }\n    }\n    console.log('json.name',json.name)\n    observer(json)\n")])])]),t("h2",{attrs:{id:"数组侦测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组侦测"}},[e._v("#")]),e._v(" 数组侦测")]),e._v(" "),t("p",[e._v("思路：由于Object.defindProperty()不具备侦测数组的能力，vue通过对原生数据方法进行替换，当劫持到key是数组类型，通过自定义的数组操作方法覆盖该key原型上数组的操作方法。")]),e._v(" "),t("p",[e._v("自定义数组操作方法的实现思路，更新视图，并原生数组操作方法。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//重新定义数组原型\nconst oldArrayProperty = Array.prototype;\n//创建新对象 原型指向oldArrayProperty 扩展的新方法不会影响原型\nconst arrProto = Object.create(oldArrayProperty);\n// pop push shift unshift splice\n['pop','push','shift','unshift','splice'].forEach(name=>{\n    arrProto[name] = function () {\n        //更新视图\n        updateView();\n        //调用原生数组更新方法\n        oldArrayProperty[name].call(this,...arguments)\n    }\n});\n\nfunction observer(target){\n    if(typeof target !== 'object' || target === null){\n        return;\n    }\n\n    if(Array.isArray(target)){\n        target .__proto__ =  arrProto\n    }\n    for(key in target){\n        defineReactive(target,key,target[key])\n        console.log(key)\n    }\n}\n\nfunction updateView() {\n    console.log('更新视图')\n}\nfunction defineReactive (target,key,val){\n    //递归调用\n    observer(target[key]);\n    Object.defineProperty(target,key,{\n        get() {\n            console.log('get');\n            return val;\n        },\n        set:function (newValue) {\n            console.log('set');\n            if(newValue !== val){\n                target[key] = newValue;\n            }\n        }\n    })\n}\nlet json = {\n    name:'kira',\n    age:30,\n    address:{\n        text1:{\n            des1:1,\n            des2:3\n        },\n        text2:2\n    }\n};\nconsole.log('json.name',json.name);\nobserver(json);\n\n")])])])])}),[],!1,null,null,null);n.default=a.exports}}]);