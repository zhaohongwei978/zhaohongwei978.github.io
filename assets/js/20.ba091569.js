(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{208:function(t,e,n){"use strict";n.r(e);var a=n(5),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"js问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#js问题"}},[t._v("#")]),t._v(" js问题")]),t._v(" "),n("h2",{attrs:{id:"oject-assign的浅拷贝问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#oject-assign的浅拷贝问题"}},[t._v("#")]),t._v(" Oject.assign的浅拷贝问题？")]),t._v(" "),n("p",[t._v("Object.assign 只能拷贝第一层。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("let a = {a:1,b:2}\nlet b= {c:3,d:{name:'kira'}};\n\nlet obj = Object.assign({},a,b);\nconsole.log(obj);\n//{ a: 1, b: 2, c: 3, d: { name: 'kira' } }\n\na.a = 66;\nconsole.log(obj); //修改a发现obj并没有被改变。\n// { a: 1, b: 2, c: 3, d: { name: 'kira' } }\nb.d.name = 'test';\nconsole.log(obj);//修改name时候，发现obj被改变了。\n//{ a: 1, b: 2, c: 3, d: { name: 'test' } }\nc\n")])])]),n("h2",{attrs:{id:"requestanimationframe对比settimeout"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe对比settimeout"}},[t._v("#")]),t._v(" requestAnimationFrame对比setTimeOut")]),t._v(" "),n("ul",[n("li",[t._v("没有办法保证，回调函数一定会在setTimeout()指定的时间执行。")]),t._v(" "),n("li",[t._v("把浏览器切换到后台，setTimeOut还会一直执行。")]),t._v(" "),n("li",[t._v("在页面渲染结束后才会开始执行。")]),t._v(" "),n("li",[t._v("requestAnimationFrame 执行时机早，在重绘阶段 就开始执行了。")]),t._v(" "),n("li",[t._v("动画更加流畅 60帧/s，既16.67ms更新一次视图。这个时机是符合人眼的。频率是自己定的")]),t._v(" "),n("li",[t._v("setTimeOut手动设置多少毫秒增加多少像素，requestAnimationFrame自动控制.\nsetTimeOut手动设置时间来执行，如果手动设置setTimeOut(fn,0)执行代码前等待的毫秒数为0，但并不是立即执行的，这是因为setTimeout有一个最小执行时间。")])]),t._v(" "),n("p",[t._v("HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔）不得低于4毫秒。实际上可能为 4毫秒后才事件推入任务队列。如果此时主线程不为空，也不会读取推出异步队列的setTimeOut.")]),t._v(" "),n("p",[t._v("执行效率问题")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("虽然两段代码执行效果一样，但是第二段代码(16.7ms/3)就要执行一次函数，很浪费性能。\n如果每次增加10或者更大，使用setTimeOut会有明显卡顿卡。\nlet currentWidth = 100\nconst maxWidth = 640\nfunction animate()\n    currentWidth + = 3;\n    if(currentWidth<maxWidth){\n        $div.css('left',currentWidth)\n        setTimeOut(animate,16.7)\n    }\n}\nanimate();\n\n//假设我们让每次增加1px\nlet currentWidth = 100\nconst maxWidth = 640\nfunction animate()\n    currentWidth + = 1;//每次增加1px\n    if(currentWidth<maxWidth){\n        $div.css('left',currentWidth)\n        setTimeOut(animate,16.7/3) //增加setTimeOut的执行频率\n    }\n}\nanimate();\n")])])]),n("h2",{attrs:{id:"documentfragement-vs-document"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#documentfragement-vs-document"}},[t._v("#")]),t._v(" DocumentFragement VS Document")]),t._v(" "),n("ul",[n("li",[t._v("区别:DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。")])]),t._v(" "),n("p",[t._v("DocumentFragment节点代表一个文档的片段，本身是一个完整的DOM树结构。它没有父节点，不属于Document。但是可以插入任意数量的子节点。但是它不属于当前文档。比直接操作DOM树快。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("//简单使用\nvar carInfoEl = document.querySelector('.car-info')\nconst fragment = document.createDocumentFragment() //创建fragement\ncarDetail.carInfo.map(item => {\n      var li = document.createElement('li')\n      li.innerHTML = '<span class=\"key\">' + item.split(':')[0] + '</span > <span span class=\"value\" >' + item.split(':')[1] + '</span>'\n      fragment.appendChild(li)//把真实DOM append到 fragement上\n})\ncarInfoEl.appendChild(fragment) //把fragement添加到真实DOM上。\n")])])]),n("h2",{attrs:{id:"在前端如何处理几万条数据的情况"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#在前端如何处理几万条数据的情况"}},[t._v("#")]),t._v(" 在前端如何处理几万条数据的情况？")]),t._v(" "),n("p",[t._v("通过使用DocumentFragement。存储每次要插入的文档。\n使用requestAnimationFragement动态 在真实DOM上添加 fragement。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("    setTimeout(() => {\n    // 插入十万条数据\n    const total = 100000;\n    // 一次插入的数据\n    const once = 20;\n    // 插入数据需要的次数\n    const loopCount = Math.ceil(total / once);\n    let countOfRender = 0;\n    const ul = document.querySelector('ul');\n    // 添加数据的方法\n    function add() {\n        const fragment = document.createDocumentFragment();\n        for(let i = 0; i < once; i++) {\n        const li = document.createElement('li');\n        li.innerText = Math.floor(Math.random() * total);\n        fragment.appendChild(li);\n        }\n        ul.appendChild(fragment);\n        countOfRender += 1;\n        loop();\n    }\n    function loop() {\n        if(countOfRender < loopCount) {\n        window.requestAnimationFrame(add);\n        }\n    }\n    loop();\n    }, 0)\n\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);