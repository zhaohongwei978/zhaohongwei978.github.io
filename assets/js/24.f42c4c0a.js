(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{214:function(t,n,e){"use strict";e.r(n);var a=e(5),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"js-问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-问题"}},[t._v("#")]),t._v(" js 问题")]),t._v(" "),e("h2",{attrs:{id:"oject-assign-的浅拷贝问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oject-assign-的浅拷贝问题"}},[t._v("#")]),t._v(" Oject.assign 的浅拷贝问题？")]),t._v(" "),e("p",[t._v("Object.assign 只能拷贝第一层。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("let a = {a:1,b:2}\nlet b= {c:3,d:{name:'kira'}};\n\nlet obj = Object.assign({},a,b);\nconsole.log(obj);\n//{ a: 1, b: 2, c: 3, d: { name: 'kira' } }\n\na.a = 66;\nconsole.log(obj); //修改a发现obj并没有被改变。\n// { a: 1, b: 2, c: 3, d: { name: 'kira' } }\nb.d.name = 'test';\nconsole.log(obj);//修改name时候，发现obj被改变了。\n//{ a: 1, b: 2, c: 3, d: { name: 'test' } }\nc\n")])])]),e("h2",{attrs:{id:"requestanimationframe-对比-settimeout"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#requestanimationframe-对比-settimeout"}},[t._v("#")]),t._v(" requestAnimationFrame 对比 setTimeOut")]),t._v(" "),e("ul",[e("li",[t._v("没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。")]),t._v(" "),e("li",[t._v("把浏览器切换到后台，setTimeOut 还会一直执行。")]),t._v(" "),e("li",[t._v("在页面渲染结束后才会开始执行。")]),t._v(" "),e("li",[t._v("requestAnimationFrame 执行时机早，在重绘阶段 就开始执行了。")]),t._v(" "),e("li",[t._v("动画更加流畅 60 帧/s，既 16.67ms 更新一次视图。这个时机是符合人眼的。频率是自己定的")]),t._v(" "),e("li",[t._v("setTimeOut 手动设置多少毫秒增加多少像素，requestAnimationFrame 自动控制.\nsetTimeOut 手动设置时间来执行，如果手动设置 setTimeOut(fn,0)执行代码前等待的毫秒数为 0，但并不是立即执行的，这是因为 setTimeout 有一个最小执行时间。")])]),t._v(" "),e("p",[t._v("HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔）不得低于 4 毫秒。实际上可能为 4 毫秒后才事件推入任务队列。如果此时主线程不为空，也不会读取推出异步队列的 setTimeOut.")]),t._v(" "),e("p",[t._v("执行效率问题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("虽然两段代码执行效果一样，但是第二段代码(16.7ms/3)就要执行一次函数，很浪费性能。\n如果每次增加10或者更大，使用setTimeOut会有明显卡顿卡。\nlet currentWidth = 100\nconst maxWidth = 640\nfunction animate()\n    currentWidth + = 3;\n    if(currentWidth<maxWidth){\n        $div.css('left',currentWidth)\n        setTimeOut(animate,16.7)\n    }\n}\nanimate();\n\n//假设我们让每次增加1px\nlet currentWidth = 100\nconst maxWidth = 640\nfunction animate()\n    currentWidth + = 1;//每次增加1px\n    if(currentWidth<maxWidth){\n        $div.css('left',currentWidth)\n        setTimeOut(animate,16.7/3) //增加setTimeOut的执行频率\n    }\n}\nanimate();\n")])])]),e("h2",{attrs:{id:"documentfragement-vs-document"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#documentfragement-vs-document"}},[t._v("#")]),t._v(" DocumentFragement VS Document")]),t._v(" "),e("ul",[e("li",[t._v("区别:DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。")])]),t._v(" "),e("p",[t._v("DocumentFragment 节点代表一个文档的片段，本身是一个完整的 DOM 树结构。它没有父节点，不属于 Document。但是可以插入任意数量的子节点。但是它不属于当前文档。比直接操作 DOM 树快。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("//简单使用\nvar carInfoEl = document.querySelector('.car-info')\nconst fragment = document.createDocumentFragment() //创建fragement\ncarDetail.carInfo.map(item => {\n      var li = document.createElement('li')\n      li.innerHTML = '<span class=\"key\">' + item.split(':')[0] + '</span > <span span class=\"value\" >' + item.split(':')[1] + '</span>'\n      fragment.appendChild(li)//把真实DOM append到 fragement上\n})\ncarInfoEl.appendChild(fragment) //把fragement添加到真实DOM上。\n")])])]),e("h2",{attrs:{id:"在前端如何处理几万条数据的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在前端如何处理几万条数据的情况"}},[t._v("#")]),t._v(" 在前端如何处理几万条数据的情况？")]),t._v(" "),e("p",[t._v("通过使用 DocumentFragement。存储每次要插入的文档。\n使用 requestAnimationFragement 动态 在真实 DOM 上添加 fragement。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("    setTimeout(() => {\n    // 插入十万条数据\n    const total = 100000;\n    // 一次插入的数据\n    const once = 20;\n    // 插入数据需要的次数\n    const loopCount = Math.ceil(total / once);\n    let countOfRender = 0;\n    const ul = document.querySelector('ul');\n    // 添加数据的方法\n    function add() {\n        const fragment = document.createDocumentFragment();\n        for(let i = 0; i < once; i++) {\n        const li = document.createElement('li');\n        li.innerText = Math.floor(Math.random() * total);\n        fragment.appendChild(li);\n        }\n        ul.appendChild(fragment);\n        countOfRender += 1;\n        loop();\n    }\n    function loop() {\n        if(countOfRender < loopCount) {\n        window.requestAnimationFrame(add);\n        }\n    }\n    loop();\n    }, 0)\n\n")])])]),e("h2",{attrs:{id:"romise-状态不能被二次改变问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#romise-状态不能被二次改变问题"}},[t._v("#")]),t._v(" romise 状态不能被二次改变问题")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("new Promise(function(resolve,reject){\n    resoleve()\n    throw Error('error')\n}).then(function(){\n    console.log('resolve')\n}).catch(function(){\n    console.log('err')\n})\n//打印结果 resolve\nthrow Error 并不会触发 catch 的执行\n")])])]),e("h2",{attrs:{id:"原型链问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链问题"}},[t._v("#")]),t._v(" 原型链问题")]),t._v(" "),e("p",[t._v("此题考察的是对原型链继承关系的理解，和对 new 的认识。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object.prototype.a = function(){\n    console.log('object')\n}\nFunction.prototype.a = function(){\n    consoloe.log('function')\n}\nfunction A(){\n\n}\n\nlet a = new A();\na.a(); // 打印结果是 object，找的是Object上的a\n因为 我们new A();首先a会在 构造函数上找，构造函数上找不到。\nnew的过程 \n1创建空对象{}\n2把a的原型链指向Object\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);