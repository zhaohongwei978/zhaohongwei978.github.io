<!DOCTYPE html>
<html lang="ZH">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 问题 | Kira技术博客</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content=" ">
    <link rel="preload" href="/assets/css/0.styles.2d08b339.css" as="style"><link rel="preload" href="/assets/js/app.ec814f8d.js" as="script"><link rel="preload" href="/assets/js/2.1beba725.js" as="script"><link rel="preload" href="/assets/js/30.e3345e0d.js" as="script"><link rel="preload" href="/assets/js/4.f49d0a18.js" as="script"><link rel="prefetch" href="/assets/js/10.3506e754.js"><link rel="prefetch" href="/assets/js/11.cba2c310.js"><link rel="prefetch" href="/assets/js/12.af69a636.js"><link rel="prefetch" href="/assets/js/13.f6a7ac1b.js"><link rel="prefetch" href="/assets/js/14.2120d959.js"><link rel="prefetch" href="/assets/js/15.05eac51c.js"><link rel="prefetch" href="/assets/js/16.56599f66.js"><link rel="prefetch" href="/assets/js/17.bb01a3bd.js"><link rel="prefetch" href="/assets/js/18.0a0f78db.js"><link rel="prefetch" href="/assets/js/19.706f2680.js"><link rel="prefetch" href="/assets/js/20.312149a1.js"><link rel="prefetch" href="/assets/js/21.3e17c9d6.js"><link rel="prefetch" href="/assets/js/22.faf55330.js"><link rel="prefetch" href="/assets/js/23.0900c539.js"><link rel="prefetch" href="/assets/js/24.1524002c.js"><link rel="prefetch" href="/assets/js/25.842b8117.js"><link rel="prefetch" href="/assets/js/26.a3060bf1.js"><link rel="prefetch" href="/assets/js/27.397be639.js"><link rel="prefetch" href="/assets/js/28.18fef214.js"><link rel="prefetch" href="/assets/js/29.b7e70c9d.js"><link rel="prefetch" href="/assets/js/3.3f31f084.js"><link rel="prefetch" href="/assets/js/31.7914ef08.js"><link rel="prefetch" href="/assets/js/32.624fedeb.js"><link rel="prefetch" href="/assets/js/33.f672cfe5.js"><link rel="prefetch" href="/assets/js/34.7344c7d0.js"><link rel="prefetch" href="/assets/js/35.54f13e9d.js"><link rel="prefetch" href="/assets/js/36.33fa8f4b.js"><link rel="prefetch" href="/assets/js/37.74868711.js"><link rel="prefetch" href="/assets/js/38.71668025.js"><link rel="prefetch" href="/assets/js/39.08f04fcd.js"><link rel="prefetch" href="/assets/js/40.9795d5c8.js"><link rel="prefetch" href="/assets/js/41.e200ab85.js"><link rel="prefetch" href="/assets/js/42.6806bf48.js"><link rel="prefetch" href="/assets/js/43.b898c7de.js"><link rel="prefetch" href="/assets/js/44.9db33f5b.js"><link rel="prefetch" href="/assets/js/45.d3279a7c.js"><link rel="prefetch" href="/assets/js/46.964c633f.js"><link rel="prefetch" href="/assets/js/47.ddb9f857.js"><link rel="prefetch" href="/assets/js/48.35c25b22.js"><link rel="prefetch" href="/assets/js/5.a98fc76a.js"><link rel="prefetch" href="/assets/js/6.c6876b67.js"><link rel="prefetch" href="/assets/js/7.a8788f1e.js"><link rel="prefetch" href="/assets/js/8.d5300ffb.js"><link rel="prefetch" href="/assets/js/9.a8a63974.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2d08b339.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Kira技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about/project/项目总结.html" class="nav-link">
  项目经历
</a></div><div class="nav-item"><a href="/about/basics/事件流.html" class="nav-link">
  js基础
</a></div><div class="nav-item"><a href="/about/vue/生命周期.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/about/question/vue.html" class="nav-link">
  常见考点
</a></div><div class="nav-item"><a href="/about/nature/节流防抖.html" class="nav-link">
  性能优化
</a></div> <a href="https://github.com/zhaohongwei978" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about/project/项目总结.html" class="nav-link">
  项目经历
</a></div><div class="nav-item"><a href="/about/basics/事件流.html" class="nav-link">
  js基础
</a></div><div class="nav-item"><a href="/about/vue/生命周期.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/about/question/vue.html" class="nav-link">
  常见考点
</a></div><div class="nav-item"><a href="/about/nature/节流防抖.html" class="nav-link">
  性能优化
</a></div> <a href="https://github.com/zhaohongwei978" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/about/basics/事件流.html" class="sidebar-link">事件流</a></li><li><a href="/about/basics/数据类型.html" class="sidebar-link">数据类型</a></li><li><a href="/about/basics/数组操作.html" class="sidebar-link">数组操作</a></li><li><a href="/about/basics/new的过程.html" class="sidebar-link">new 的过程</a></li><li><a href="/about/basics/原型链.html" class="sidebar-link">原型链</a></li><li><a href="/about/basics/闭包.html" class="sidebar-link">作用域和闭包</a></li><li><a href="/about/basics/异步.html" class="sidebar-link">异步</a></li><li><a href="/about/brower/事件循环.html" class="sidebar-link">事件循环</a></li><li><a href="/about/brower/渲染过程.html" class="sidebar-link">渲染过程</a></li><li><a href="/about/basics/arguments.html" class="sidebar-link">arguments 参数传递</a></li><li><a href="/about/basics/promise.html" class="sidebar-link">promise</a></li><li><a href="/about/basics/ts学习.html" class="sidebar-link">ts 学习</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Wepback</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>常见考点</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/about/question/vue.html" class="sidebar-link">vue相关</a></li><li><a href="/about/question/js.html" aria-current="page" class="active sidebar-link">js 问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#underfind-和-null-的区别" class="sidebar-link">underfind 和 null 的区别?</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#null-和-underfind-目前的用法" class="sidebar-link">null 和 underfind 目前的用法</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#javascript-中包含-6-种数据类型" class="sidebar-link">JavaScript 中包含 6 种数据类型？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#清除浮动的写法" class="sidebar-link">清除浮动的写法</a></li></ul></li><li class="sidebar-sub-header"><a href="/about/question/js.html#_1px不精准问题" class="sidebar-link">1px不精准问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#为什么会出现1px不精准" class="sidebar-link">为什么会出现1px不精准？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#方法1-通过border-img" class="sidebar-link">方法1 通过border-img</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#方法2-使用box-shadow实现" class="sidebar-link">方法2 使用box-shadow实现</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#方法3-在伪元素中定位-通过transform缩放" class="sidebar-link">方法3 在伪元素中定位，通过transform缩放</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#设置viewport的scale值" class="sidebar-link">设置viewport的scale值</a></li></ul></li><li class="sidebar-sub-header"><a href="/about/question/js.html#前端性能监控" class="sidebar-link">前端性能监控？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#oject-assign-的浅拷贝问题" class="sidebar-link">Oject.assign 的浅拷贝问题？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#js-实现一个单例模式" class="sidebar-link">js 实现一个单例模式</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#requestanimationframe-对比-settimeout" class="sidebar-link">requestAnimationFrame 对比 setTimeOut</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#documentfragement-vs-document" class="sidebar-link">DocumentFragement VS Document</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#在前端如何处理几万条数据的情况" class="sidebar-link">在前端如何处理几万条数据的情况？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#promise-状态不能被二次改变问题" class="sidebar-link">Promise 状态不能被二次改变问题</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#原型链问题" class="sidebar-link">原型链问题</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#for-in-对比-for-of" class="sidebar-link">for in 对比 for of</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#for-in-是为普通对象设计的" class="sidebar-link">for-in 是为普通对象设计的</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#for-of-遍历数组更加方便" class="sidebar-link">for-of 遍历数组更加方便</a></li></ul></li></ul></li><li><a href="/about/question/移动端问题.html" class="sidebar-link">移动端问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-问题"><a href="#js-问题" class="header-anchor">#</a> js 问题</h1> <h2 id="underfind-和-null-的区别"><a href="#underfind-和-null-的区别" class="header-anchor">#</a> underfind 和 null 的区别?</h2> <p>JavaScript 语言居然有两个表示&quot;无&quot;的值：undefined 和 null。
最初设计</p> <ul><li>null 是一个表示&quot;无&quot;的对象，转为数值时为 0；
// Number(null) 0</li> <li>undefined 是一个表示&quot;无&quot;的原始值，转为数值时为 NaN。
// Number(undefined)</li></ul> <h3 id="null-和-underfind-目前的用法"><a href="#null-和-underfind-目前的用法" class="header-anchor">#</a> null 和 underfind 目前的用法</h3> <p>null 表示&quot;没有对象&quot;，即该处不应该有值。
undefined 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</p> <ul><li>1 变量被声明了，但没有赋值时，就等于 undefined。</li> <li>2 调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li> <li>3 对象没有赋值的属性，该属性的值为 undefined。</li> <li>4 函数没有返回值时，默认返回 undefined。</li></ul> <p>这样判断一个值是否存在，就可以用
objA.valueA === undefined // 不应使用 null 因为 undefined == null，而 null 表示该值定义为空值。</p> <div class="language- extra-class"><pre class="language-text"><code>underfind === null // false
typeof underfind //underdind
typeof null //object
</code></pre></div><h3 id="javascript-中包含-6-种数据类型"><a href="#javascript-中包含-6-种数据类型" class="header-anchor">#</a> JavaScript 中包含 6 种数据类型？</h3> <p>5 种基本数据类型 1 个复杂数据类型</p> <ul><li>underfind</li> <li>null</li> <li>string</li> <li>number</li> <li>boolean</li> <li>object</li></ul> <h3 id="清除浮动的写法"><a href="#清除浮动的写法" class="header-anchor">#</a> 清除浮动的写法</h3> <ul><li>1 overfow:hidden</li> <li>2 元素末尾追加 div.style=&quot;clear:both&quot;</li> <li>3 通过伪类</li></ul> <div class="language- extra-class"><pre class="language-text"><code>.clearfix::after{
    content:'' //伪元素内容 为''让伪元素不显示
    //clear属性只能在块级元素上其作用，这就是清除浮动样式中display:block的作用。
    display:'block',
    height:0让元素高度为0并且不显示
    clear:both;//清除浮动
    visiblity:hidden;//让元素渲染但是不显示
    clear:both;//清除浮动
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>清除浮动作用

1:解决子元素浮动父元素高度塌陷的问题
</code></pre></div><h2 id="_1px不精准问题"><a href="#_1px不精准问题" class="header-anchor">#</a> 1px不精准问题？</h2> <p>现象，在高清屏下，移动端的1px 会很粗。</p> <h3 id="为什么会出现1px不精准"><a href="#为什么会出现1px不精准" class="header-anchor">#</a> 为什么会出现1px不精准？</h3> <p>DPR(devicePixelRatio) 设备像素比，它是默认缩放为100%的情况下，设备像素和CSS像素的比值。</p> <p>目前主流的屏幕DPR=2 （iPhone 8）,或者3 （iPhone 8 Plus）。拿2倍屏来说，设备的物理像素要实现1像素，而DPR=2，所以css 像素只能是 0.5。一般设计稿是按照750来设计的，它上面的1px是以750来参照的，而我们写css样式是以设备375为参照的，所以我们应该写的0.5px就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。</p> <ul><li>window.devicePixelRatio=物理像素 /CSS像素</li></ul> <h3 id="方法1-通过border-img"><a href="#方法1-通过border-img" class="header-anchor">#</a> 方法1 通过border-img</h3> <div class="language-angular2 extra-class"><pre class="language-text"><code>  border: 1px solid transparent;
  border-image: url('./../../image/96.jpg') 2 repeat;
</code></pre></div><h3 id="方法2-使用box-shadow实现"><a href="#方法2-使用box-shadow实现" class="header-anchor">#</a> 方法2 使用box-shadow实现</h3> <p>仔细看,能看出这是阴影不是边框。</p> <div class="language-angular2 extra-class"><pre class="language-text"><code>box-shadow: x偏移量 y偏移量 偏移半径 颜色;
box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线
            1px  0  1px -1px #e5e5e5,   //右边线
            0  1px  1px -1px #e5e5e5,   //下边线
            -1px 0  1px -1px #e5e5e5;   //左边线
</code></pre></div><h3 id="方法3-在伪元素中定位-通过transform缩放"><a href="#方法3-在伪元素中定位-通过transform缩放" class="header-anchor">#</a> 方法3 在伪元素中定位，通过transform缩放</h3> <div class="language-angular2 extra-class"><pre class="language-text"><code>setOnePx{
  position: relative;
  &amp;::after{
    position: absolute;
    content: '';
    background-color: #e5e5e5;
    display: block;
    width: 100%;
    height: 1px; /*no*/
    transform: scale(1, 0.5);
    top: 0;
    left: 0;
  }
}
</code></pre></div><h3 id="设置viewport的scale值"><a href="#设置viewport的scale值" class="header-anchor">#</a> 设置viewport的scale值</h3> <div class="language-angular2 extra-class"><pre class="language-text"><code>&lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;
&lt;script&gt;
          var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);
          //下面是根据设备像素设置viewport
          if (window.devicePixelRatio == 1) {
              viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');
          }
          if (window.devicePixelRatio == 2) {
              viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no');
          }
          if (window.devicePixelRatio == 3) {
              viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no');
          }
          var docEl = document.documentElement;
          var fontsize = 32* (docEl.clientWidth / 750) + 'px';
          docEl.style.fontSize = fontsize;
      &lt;/script&gt;
</code></pre></div><h2 id="前端性能监控"><a href="#前端性能监控" class="header-anchor">#</a> 前端性能监控？</h2> <ul><li><p>通过performance API 包含了页面加载的各个阶段的起始时间</p></li> <li><p>window.performance</p></li> <li><p>打印window.performance.timing</p></li></ul> <div class="language-angular2 extra-class"><pre class="language-text"><code>    timing: {
        navigationStart: 同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。
        unloadEventStart: 上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。
        unloadEventEnd: 和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。
        redirectStart: 第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。
        redirectEnd: 最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0. 
        fetchStart: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。
        domainLookupStart: DNS 域名查询开始的UNIX时间戳,如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。
        domainLookupEnd: DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        connectStart: HTTP（TCP） 域名查询结束的时间戳，如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。
        connectEnd: HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳，如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。
        secureConnectionStart: HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。
        requestStart: 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。
        responseStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳，如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。
        responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。
        domLoading: 当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。
        domInteractive: 当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。
        domContentLoadedEventStart: 当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。
        domContentLoadedEventEnd: 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。
        domComplete: 当前文档解析完成，即Document.readyState 变为 'complete'且相对应的readystatechange 被触发时的时间戳
        loadEventStart: load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。
        loadEventEnd: 当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0。
}
</code></pre></div><div class="language-angular2 extra-class"><pre class="language-text"><code>// 重定向耗时
redirect: timing.redirectEnd - timing.redirectStart,
// DOM 渲染耗时
dom: timing.domComplete - timing.domLoading,
// 页面加载耗时
load: timing.loadEventEnd - timing.navigationStart,
// 页面卸载耗时
unload: timing.unloadEventEnd - timing.unloadEventStart,
// 请求耗时
request: timing.responseEnd - timing.requestStart,
// 获取性能信息时当前时间
time: new Date().getTime(),

//白屏时间指从输入网址，到页面开始显示内容的时间。
&lt;script&gt;
    let whiteScreen = new Date() - performance.timing.navigationStart
&lt;/script&gt;
</code></pre></div><h2 id="oject-assign-的浅拷贝问题"><a href="#oject-assign-的浅拷贝问题" class="header-anchor">#</a> Oject.assign 的浅拷贝问题？</h2> <p>Object.assign 只能拷贝第一层。</p> <div class="language- extra-class"><pre class="language-text"><code>let a = {a:1,b:2}
let b= {c:3,d:{name:'kira'}};

let obj = Object.assign({},a,b);
console.log(obj);
//{ a: 1, b: 2, c: 3, d: { name: 'kira' } }

a.a = 66;
console.log(obj); //修改a发现obj并没有被改变。
// { a: 1, b: 2, c: 3, d: { name: 'kira' } }
b.d.name = 'test';
console.log(obj);//修改name时候，发现obj被改变了。
//{ a: 1, b: 2, c: 3, d: { name: 'test' } }
c
</code></pre></div><h2 id="js-实现一个单例模式"><a href="#js-实现一个单例模式" class="header-anchor">#</a> js 实现一个单例模式</h2> <p>思路：保证一个类只有一个对象，一般先判断对象是否存在，如果存在直接返回该对象。如果不存在，创建对象并返回。
比如后台的 jdbc 连接就是典型的单例，防止每次使用 sql 都要创建 sql 连接对象。</p> <h2 id="requestanimationframe-对比-settimeout"><a href="#requestanimationframe-对比-settimeout" class="header-anchor">#</a> requestAnimationFrame 对比 setTimeOut</h2> <ul><li>没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。</li> <li>把浏览器切换到后台，setTimeOut 还会一直执行。</li> <li>在页面渲染结束后才会开始执行。</li> <li>requestAnimationFrame 执行时机早，在重绘阶段 就开始执行了。</li> <li>动画更加流畅 60 帧/s，既 16.67ms 更新一次视图。这个时机是符合人眼的。频率是自己定的</li> <li>setTimeOut 手动设置多少毫秒增加多少像素，requestAnimationFrame 自动控制.
setTimeOut 手动设置时间来执行，如果手动设置 setTimeOut(fn,0)执行代码前等待的毫秒数为 0，但并不是立即执行的，这是因为 setTimeout 有一个最小执行时间。</li></ul> <p>HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔）不得低于 4 毫秒。实际上可能为 4 毫秒后才事件推入任务队列。如果此时主线程不为空，也不会读取推出异步队列的 setTimeOut.</p> <p>执行效率问题</p> <div class="language- extra-class"><pre class="language-text"><code>虽然两段代码执行效果一样，但是第二段代码(16.7ms/3)就要执行一次函数，很浪费性能。
如果每次增加10或者更大，使用setTimeOut会有明显卡顿卡。
let currentWidth = 100
const maxWidth = 640
function animate()
    currentWidth + = 3;
    if(currentWidth&lt;maxWidth){
        $div.css('left',currentWidth)
        setTimeOut(animate,16.7)
    }
}
animate();

//假设我们让每次增加1px
let currentWidth = 100
const maxWidth = 640
function animate()
    currentWidth + = 1;//每次增加1px
    if(currentWidth&lt;maxWidth){
        $div.css('left',currentWidth)
        setTimeOut(animate,16.7/3) //增加setTimeOut的执行频率
    }
}
animate();
</code></pre></div><h2 id="documentfragement-vs-document"><a href="#documentfragement-vs-document" class="header-anchor">#</a> DocumentFragement VS Document</h2> <ul><li>区别:DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</li></ul> <p>DocumentFragment 节点代表一个文档的片段，本身是一个完整的 DOM 树结构。它没有父节点，不属于 Document。但是可以插入任意数量的子节点。但是它不属于当前文档。比直接操作 DOM 树快。</p> <div class="language- extra-class"><pre class="language-text"><code>//简单使用
var carInfoEl = document.querySelector('.car-info')
const fragment = document.createDocumentFragment() //创建fragement
carDetail.carInfo.map(item =&gt; {
      var li = document.createElement('li')
      li.innerHTML = '&lt;span class=&quot;key&quot;&gt;' + item.split(':')[0] + '&lt;/span &gt; &lt;span span class=&quot;value&quot; &gt;' + item.split(':')[1] + '&lt;/span&gt;'
      fragment.appendChild(li)//把真实DOM append到 fragement上
})
carInfoEl.appendChild(fragment) //把fragement添加到真实DOM上。
</code></pre></div><h2 id="在前端如何处理几万条数据的情况"><a href="#在前端如何处理几万条数据的情况" class="header-anchor">#</a> 在前端如何处理几万条数据的情况？</h2> <p>通过使用 DocumentFragement。存储每次要插入的文档。
使用 requestAnimationFragement 动态 在真实 DOM 上添加 fragement。</p> <div class="language- extra-class"><pre class="language-text"><code>    setTimeout(() =&gt; {
    // 插入十万条数据
    const total = 100000;
    // 一次插入的数据
    const once = 20;
    // 插入数据需要的次数
    const loopCount = Math.ceil(total / once);
    let countOfRender = 0;
    const ul = document.querySelector('ul');
    // 添加数据的方法
    function add() {
        const fragment = document.createDocumentFragment();
        for(let i = 0; i &lt; once; i++) {
        const li = document.createElement('li');
        li.innerText = Math.floor(Math.random() * total);
        fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
    }
    function loop() {
        if(countOfRender &lt; loopCount) {
        window.requestAnimationFrame(add);
        }
    }
    loop();
    }, 0)

</code></pre></div><h2 id="promise-状态不能被二次改变问题"><a href="#promise-状态不能被二次改变问题" class="header-anchor">#</a> Promise 状态不能被二次改变问题</h2> <div class="language- extra-class"><pre class="language-text"><code>new Promise(function(resolve,reject){
    resoleve()
    throw Error('error')
}).then(function(){
    console.log('resolve')
}).catch(function(){
    console.log('err')
})
//打印结果 resolve
throw Error 并不会触发 catch 的执行
</code></pre></div><h2 id="原型链问题"><a href="#原型链问题" class="header-anchor">#</a> 原型链问题</h2> <p>此题考察的是对原型链继承关系的理解，和对 new 的认识。</p> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.a = function(){
    console.log('object')
}
Function.prototype.a = function(){
    consoloe.log('function')
}
function A(){

}

let a = new A();
a.a(); // 打印结果是 object，找的是Object上的a
因为 我们new A();首先a会在 构造函数上找，构造函数上找不到。
new的过程
1创建空对象{}
2把a的原型链指向Object
</code></pre></div><h2 id="for-in-对比-for-of"><a href="#for-in-对比-for-of" class="header-anchor">#</a> for in 对比 for of</h2> <h3 id="for-in-是为普通对象设计的"><a href="#for-in-是为普通对象设计的" class="header-anchor">#</a> for-in 是为普通对象设计的</h3> <h3 id="for-of-遍历数组更加方便"><a href="#for-of-遍历数组更加方便" class="header-anchor">#</a> for-of 遍历数组更加方便</h3></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/zhaohongwei978/edit/master/docs/about/question/js.md" target="_blank" rel="noopener noreferrer">在github上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">11/27/2020, 7:52:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/about/question/vue.html" class="prev">
        vue相关
      </a></span> <span class="next"><a href="/about/question/移动端问题.html">
        移动端问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.ec814f8d.js" defer></script><script src="/assets/js/2.1beba725.js" defer></script><script src="/assets/js/30.e3345e0d.js" defer></script><script src="/assets/js/4.f49d0a18.js" defer></script>
  </body>
</html>
