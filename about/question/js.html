<!DOCTYPE html>
<html lang="ZH">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js 问题 | Kira技术博客</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content=" ">
    <link rel="preload" href="/assets/css/0.styles.2d08b339.css" as="style"><link rel="preload" href="/assets/js/app.65d339c7.js" as="script"><link rel="preload" href="/assets/js/2.deebf64a.js" as="script"><link rel="preload" href="/assets/js/39.aefb1b3a.js" as="script"><link rel="preload" href="/assets/js/5.e38e9f60.js" as="script"><link rel="prefetch" href="/assets/js/10.0b5a8b75.js"><link rel="prefetch" href="/assets/js/11.a98c2d4b.js"><link rel="prefetch" href="/assets/js/12.f6aa2882.js"><link rel="prefetch" href="/assets/js/13.4a5083d7.js"><link rel="prefetch" href="/assets/js/14.d9a8ea5b.js"><link rel="prefetch" href="/assets/js/15.2251815e.js"><link rel="prefetch" href="/assets/js/16.c5c55536.js"><link rel="prefetch" href="/assets/js/17.b60d78f9.js"><link rel="prefetch" href="/assets/js/18.1b615301.js"><link rel="prefetch" href="/assets/js/19.0103420a.js"><link rel="prefetch" href="/assets/js/20.ae4d8f9c.js"><link rel="prefetch" href="/assets/js/21.1345f1e2.js"><link rel="prefetch" href="/assets/js/22.f6b1d2de.js"><link rel="prefetch" href="/assets/js/23.60ac38f6.js"><link rel="prefetch" href="/assets/js/24.05b1ccaf.js"><link rel="prefetch" href="/assets/js/25.ad688c4e.js"><link rel="prefetch" href="/assets/js/26.b86096d0.js"><link rel="prefetch" href="/assets/js/27.7c62efcf.js"><link rel="prefetch" href="/assets/js/28.b534909c.js"><link rel="prefetch" href="/assets/js/29.9d26aca2.js"><link rel="prefetch" href="/assets/js/3.e440a63a.js"><link rel="prefetch" href="/assets/js/30.b0e55768.js"><link rel="prefetch" href="/assets/js/31.352a3009.js"><link rel="prefetch" href="/assets/js/32.4d21c513.js"><link rel="prefetch" href="/assets/js/33.51823d46.js"><link rel="prefetch" href="/assets/js/34.5e819de6.js"><link rel="prefetch" href="/assets/js/35.fd7548ee.js"><link rel="prefetch" href="/assets/js/36.69317915.js"><link rel="prefetch" href="/assets/js/37.3be558fc.js"><link rel="prefetch" href="/assets/js/38.41e17763.js"><link rel="prefetch" href="/assets/js/4.b58cfd44.js"><link rel="prefetch" href="/assets/js/40.5caef311.js"><link rel="prefetch" href="/assets/js/41.f25929b6.js"><link rel="prefetch" href="/assets/js/42.4bc7ba9f.js"><link rel="prefetch" href="/assets/js/43.13b56621.js"><link rel="prefetch" href="/assets/js/44.e25d251d.js"><link rel="prefetch" href="/assets/js/45.5e2ebeac.js"><link rel="prefetch" href="/assets/js/46.9f3f4380.js"><link rel="prefetch" href="/assets/js/47.65d3d93a.js"><link rel="prefetch" href="/assets/js/48.0e124a7a.js"><link rel="prefetch" href="/assets/js/49.257ca1bf.js"><link rel="prefetch" href="/assets/js/50.60746e8e.js"><link rel="prefetch" href="/assets/js/51.3efccacb.js"><link rel="prefetch" href="/assets/js/52.9178aaca.js"><link rel="prefetch" href="/assets/js/53.31b4c18e.js"><link rel="prefetch" href="/assets/js/54.197249d9.js"><link rel="prefetch" href="/assets/js/55.28767c59.js"><link rel="prefetch" href="/assets/js/56.84d7dae2.js"><link rel="prefetch" href="/assets/js/57.78fc6a05.js"><link rel="prefetch" href="/assets/js/6.a69c061f.js"><link rel="prefetch" href="/assets/js/7.a794173a.js"><link rel="prefetch" href="/assets/js/8.c462e844.js"><link rel="prefetch" href="/assets/js/9.1ac191bb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.2d08b339.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Kira技术博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about/project/项目总结.html" class="nav-link">
  项目经历
</a></div><div class="nav-item"><a href="/about/project/微前端.html" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="/about/project/小程序架构设计.html" class="nav-link">
  小程序架构
</a></div><div class="nav-item"><a href="/about/vue/生命周期.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/about/question/vue.html" class="nav-link">
  常见考点
</a></div><div class="nav-item"><a href="/about/nature/节流防抖.html" class="nav-link">
  性能优化
</a></div> <a href="https://github.com/zhaohongwei978" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/about/project/项目总结.html" class="nav-link">
  项目经历
</a></div><div class="nav-item"><a href="/about/project/微前端.html" class="nav-link">
  微前端
</a></div><div class="nav-item"><a href="/about/project/小程序架构设计.html" class="nav-link">
  小程序架构
</a></div><div class="nav-item"><a href="/about/vue/生命周期.html" class="nav-link">
  vue
</a></div><div class="nav-item"><a href="/about/question/vue.html" class="nav-link">
  常见考点
</a></div><div class="nav-item"><a href="/about/nature/节流防抖.html" class="nav-link">
  性能优化
</a></div> <a href="https://github.com/zhaohongwei978" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/about/basics/dsBridge.html" class="sidebar-link">JSBridge通信过程</a></li><li><a href="/about/basics/事件流.html" class="sidebar-link">事件流</a></li><li><a href="/about/basics/跨域.html" class="sidebar-link">跨域</a></li><li><a href="/about/basics/generator.html" class="sidebar-link">generator</a></li><li><a href="/about/basics/Object.html" class="sidebar-link">Object</a></li><li><a href="/about/basics/数据类型.html" class="sidebar-link">数据类型</a></li><li><a href="/about/basics/数组操作.html" class="sidebar-link">数组操作</a></li><li><a href="/about/basics/new的过程.html" class="sidebar-link">new 的过程</a></li><li><a href="/about/basics/原型链.html" class="sidebar-link">原型链</a></li><li><a href="/about/basics/闭包.html" class="sidebar-link">作用域和闭包</a></li><li><a href="/about/basics/异步.html" class="sidebar-link">异步</a></li><li><a href="/about/brower/事件循环.html" class="sidebar-link">事件循环</a></li><li><a href="/about/brower/渲染过程.html" class="sidebar-link">渲染过程</a></li><li><a href="/about/basics/arguments.html" class="sidebar-link">arguments 参数传递</a></li><li><a href="/about/basics/promise.html" class="sidebar-link">promise</a></li><li><a href="/about/basics/ts学习.html" class="sidebar-link">ts 学习</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Wepback</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Http</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>常见考点</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/about/question/vue.html" class="sidebar-link">vue相关</a></li><li><a href="/about/question/js.html" aria-current="page" class="active sidebar-link">js 问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#underfind-和-null-的区别" class="sidebar-link">underfind 和 null 的区别?</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#函数声明式与函数表达式的区别" class="sidebar-link">函数声明式与函数表达式的区别</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#针对对象进行从大到小排序" class="sidebar-link">针对对象进行从大到小排序</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#js-var-a-b-c-10问题" class="sidebar-link">js var a = b = c = 10问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#null-和-underfind-目前的用法" class="sidebar-link">null 和 underfind 目前的用法</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#javascript-中包含-6-种数据类型" class="sidebar-link">JavaScript 中包含 6 种数据类型？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#清除浮动的写法" class="sidebar-link">清除浮动的写法</a></li></ul></li><li class="sidebar-sub-header"><a href="/about/question/js.html#_1px-不精准问题" class="sidebar-link">1px 不精准问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#为什么会出现-1px-不精准" class="sidebar-link">为什么会出现 1px 不精准？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#方法-1-通过-border-img" class="sidebar-link">方法 1 通过 border-img</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#方法-2-使用-box-shadow-实现" class="sidebar-link">方法 2 使用 box-shadow 实现</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#方法-3-在伪元素中定位-通过-transform-缩放" class="sidebar-link">方法 3 在伪元素中定位，通过 transform 缩放</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#设置-viewport-的-scale-值" class="sidebar-link">设置 viewport 的 scale 值</a></li></ul></li><li class="sidebar-sub-header"><a href="/about/question/js.html#前端性能监控" class="sidebar-link">前端性能监控？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#js-实现一个单例模式" class="sidebar-link">js 实现一个单例模式</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#requestanimationframe-对比-settimeout" class="sidebar-link">requestAnimationFrame 对比 setTimeOut</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#amd-和-cmd-的区别" class="sidebar-link">AMD 和 CMD 的区别？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#documentfragement-vs-document" class="sidebar-link">DocumentFragement VS Document</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#在前端如何处理几万条数据的情况" class="sidebar-link">在前端如何处理几万条数据的情况？</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#promise-状态不能被二次改变问题" class="sidebar-link">Promise 状态不能被二次改变问题</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#原型链问题" class="sidebar-link">原型链问题</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#js-模块的导出和引入" class="sidebar-link">js 模块的导出和引入</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#函数提升和变量提升" class="sidebar-link">函数提升和变量提升</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#小程序-navigateto-和-redirectto-用法和区别" class="sidebar-link">小程序 navigateTo()和 redirectTo()用法和区别</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#for-in-对比-for-of" class="sidebar-link">for in 对比 for of</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/about/question/js.html#for-in-是为普通对象设计的" class="sidebar-link">for-in 是为普通对象设计的</a></li><li class="sidebar-sub-header"><a href="/about/question/js.html#for-of-遍历数组更加方便" class="sidebar-link">for-of 遍历数组更加方便</a></li></ul></li></ul></li><li><a href="/about/question/移动端问题.html" class="sidebar-link">移动端问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>性能优化</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="js-问题"><a href="#js-问题" class="header-anchor">#</a> js 问题</h1> <h2 id="underfind-和-null-的区别"><a href="#underfind-和-null-的区别" class="header-anchor">#</a> underfind 和 null 的区别?</h2> <p>JavaScript 语言居然有两个表示&quot;无&quot;的值：undefined 和 null。
最初设计</p> <ul><li>null 是一个表示&quot;无&quot;的对象，转为数值时为 0；
// Number(null) 0</li> <li>undefined 是一个表示&quot;无&quot;的原始值，转为数值时为 NaN。
// Number(undefined)</li></ul> <h2 id="函数声明式与函数表达式的区别"><a href="#函数声明式与函数表达式的区别" class="header-anchor">#</a> 函数声明式与函数表达式的区别</h2> <p>函数声明式</p> <div class="language-angular2html extra-class"><pre class="language-text"><code>function 函数名 （参数…）{
    //something...
}
</code></pre></div><p>函数表达式</p> <p>函数表达式（Function Expression）是将函数定义为表达是语句的一部分（通常是变量赋值）。通过函数表达式定义的函数是可以命名的，也可以是匿名的。不能以function开头（立即执行函数开头按()算😄）。</p> <div class="language-angular2html extra-class"><pre class="language-text"><code>
//变量a引用了一个匿名函数表达式
var a = function(){
    //something...
}

//变量a引用了一个函数声明式
var a =  function test (){
    //something...
}

//匿名函数表达式
(function test1 () {
    //something...
})();
</code></pre></div><h2 id="针对对象进行从大到小排序"><a href="#针对对象进行从大到小排序" class="header-anchor">#</a> 针对对象进行从大到小排序</h2> <p>通过sort进行排序</p> <div class="language-angular2html extra-class"><pre class="language-text"><code>let arr = [
    { id:8,obj:'88'},
    { id:3,obj:'33'},
    { id:4,obj:'44'},
    { id:7,obj:'77'}]

arr.sort(function (a,b) {
    console.log('----a',a.id)
    console.log('----b',b)
    return b.id- a.id;
})
console.log(arr)
</code></pre></div><h2 id="js-var-a-b-c-10问题"><a href="#js-var-a-b-c-10问题" class="header-anchor">#</a> js var a = b = c = 10问题？</h2> <div class="language-angular2html extra-class"><pre class="language-text"><code>
 function fn(){
    var a = b = c = 10;  
    // 相当于 var a= 10;    b=10;（在全局var b = underfind,在函数内 b=10）   c=10;（在全局var c = underfind,在函数内 c=10)
    
 }
 fn()
 console.log(a) // 报错 a is not defind,因为a是在函数作用定义的。
 console.log(b) // 打印结果10
 console.log(c) // 打印结果10
 // 
</code></pre></div><h3 id="null-和-underfind-目前的用法"><a href="#null-和-underfind-目前的用法" class="header-anchor">#</a> null 和 underfind 目前的用法</h3> <p>null 表示&quot;没有对象&quot;，即该处不应该有值。
undefined 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</p> <ul><li>1 变量被声明了，但没有赋值时，就等于 undefined。</li> <li>2 调用函数时，应该提供的参数没有提供，该参数等于 undefined。</li> <li>3 对象没有赋值的属性，该属性的值为 undefined。</li> <li>4 函数没有返回值时，默认返回 undefined。</li></ul> <p>这样判断一个值是否存在，就可以用
objA.valueA === undefined // 不应使用 null 因为 undefined == null，而 null 表示该值定义为空值。</p> <div class="language- extra-class"><pre class="language-text"><code>underfind === null // false
typeof underfind //underdind
typeof null //object
</code></pre></div><h3 id="javascript-中包含-6-种数据类型"><a href="#javascript-中包含-6-种数据类型" class="header-anchor">#</a> JavaScript 中包含 6 种数据类型？</h3> <p>5 种基本数据类型 1 个复杂数据类型</p> <ul><li>underfind</li> <li>null</li> <li>string</li> <li>number</li> <li>boolean</li> <li>object</li></ul> <h3 id="清除浮动的写法"><a href="#清除浮动的写法" class="header-anchor">#</a> 清除浮动的写法</h3> <ul><li>1 overfow:hidden</li> <li>2 元素末尾追加 div.style=&quot;clear:both&quot;</li> <li>3 通过伪类</li></ul> <div class="language- extra-class"><pre class="language-text"><code>.clearfix::after{
    content:'' //伪元素内容 为''让伪元素不显示
    //clear属性只能在块级元素上其作用，这就是清除浮动样式中display:block的作用。
    display:'block',
    height:0让元素高度为0并且不显示
    clear:both;//清除浮动
    visiblity:hidden;//让元素渲染但是不显示
    clear:both;//清除浮动
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>清除浮动作用

1:解决子元素浮动父元素高度塌陷的问题
</code></pre></div><h2 id="_1px-不精准问题"><a href="#_1px-不精准问题" class="header-anchor">#</a> 1px 不精准问题？</h2> <p>现象，在高清屏下，移动端的 1px 会很粗。</p> <h3 id="为什么会出现-1px-不精准"><a href="#为什么会出现-1px-不精准" class="header-anchor">#</a> 为什么会出现 1px 不精准？</h3> <p>DPR(devicePixelRatio) 设备像素比，它是默认缩放为 100%的情况下，设备像素和 CSS 像素的比值。</p> <p>目前主流的屏幕 DPR=2 （iPhone 8）,或者 3 （iPhone 8 Plus）。拿 2 倍屏来说，设备的物理像素要实现 1 像素，而 DPR=2，所以 css 像素只能是 0.5。一般设计稿是按照 750 来设计的，它上面的 1px 是以 750 来参照的，而我们写 css 样式是以设备 375 为参照的，所以我们应该写的 0.5px 就好了啊！ 试过了就知道，iOS 8+系统支持，安卓系统不支持。</p> <ul><li>window.devicePixelRatio=物理像素 /CSS 像素</li></ul> <h3 id="方法-1-通过-border-img"><a href="#方法-1-通过-border-img" class="header-anchor">#</a> 方法 1 通过 border-img</h3> <div class="language-angular2 extra-class"><pre class="language-text"><code>  border: 1px solid transparent;
  border-image: url('./../../image/96.jpg') 2 repeat;
</code></pre></div><h3 id="方法-2-使用-box-shadow-实现"><a href="#方法-2-使用-box-shadow-实现" class="header-anchor">#</a> 方法 2 使用 box-shadow 实现</h3> <p>仔细看,能看出这是阴影不是边框。</p> <div class="language-angular2 extra-class"><pre class="language-text"><code>box-shadow: x偏移量 y偏移量 偏移半径 颜色;
box-shadow: 0  -1px 1px -1px #e5e5e5,   //上边线
            1px  0  1px -1px #e5e5e5,   //右边线
            0  1px  1px -1px #e5e5e5,   //下边线
            -1px 0  1px -1px #e5e5e5;   //左边线
</code></pre></div><h3 id="方法-3-在伪元素中定位-通过-transform-缩放"><a href="#方法-3-在伪元素中定位-通过-transform-缩放" class="header-anchor">#</a> 方法 3 在伪元素中定位，通过 transform 缩放</h3> <div class="language-angular2 extra-class"><pre class="language-text"><code>setOnePx{
  position: relative;
  &amp;::after{
    position: absolute;
    content: '';
    background-color: #e5e5e5;
    display: block;
    width: 100%;
    height: 1px; /*no*/
    transform: scale(1, 0.5);
    top: 0;
    left: 0;
  }
}
</code></pre></div><h3 id="设置-viewport-的-scale-值"><a href="#设置-viewport-的-scale-值" class="header-anchor">#</a> 设置 viewport 的 scale 值</h3> <div class="language-angular2 extra-class"><pre class="language-text"><code>&lt;meta name=&quot;viewport&quot; id=&quot;WebViewport&quot; content=&quot;initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;&gt;
&lt;script&gt;
          var viewport = document.querySelector(&quot;meta[name=viewport]&quot;);
          //下面是根据设备像素设置viewport
          if (window.devicePixelRatio == 1) {
              viewport.setAttribute('content', 'width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no');
          }
          if (window.devicePixelRatio == 2) {
              viewport.setAttribute('content', 'width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no');
          }
          if (window.devicePixelRatio == 3) {
              viewport.setAttribute('content', 'width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no');
          }
          var docEl = document.documentElement;
          var fontsize = 32* (docEl.clientWidth / 750) + 'px';
          docEl.style.fontSize = fontsize;
      &lt;/script&gt;
</code></pre></div><h2 id="前端性能监控"><a href="#前端性能监控" class="header-anchor">#</a> 前端性能监控？</h2> <ul><li><p>通过 performance API 包含了页面加载的各个阶段的起始时间</p></li> <li><p>window.performance</p></li> <li><p>打印 window.performance.timing</p></li></ul> <div class="language-angular2 extra-class"><pre class="language-text"><code>    timing: {
        navigationStart: 同一个浏览器上一个页面卸载(unload)结束时的时间戳。如果没有上一个页面，这个值会和fetchStart相同。
        unloadEventStart: 上一个页面unload事件抛出时的时间戳。如果没有上一个页面，这个值会返回0。
        unloadEventEnd: 和 unloadEventStart 相对应，unload事件处理完成时的时间戳。如果没有上一个页面,这个值会返回0。
        redirectStart: 第一个HTTP重定向开始时的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0。
        redirectEnd: 最后一个HTTP重定向完成时（也就是说是HTTP响应的最后一个比特直接被收到的时间）的时间戳。如果没有重定向，或者重定向中的一个不同源，这个值会返回0.
        fetchStart: 浏览器准备好使用HTTP请求来获取(fetch)文档的时间戳。这个时间点会在检查任何应用缓存之前。
        domainLookupStart: DNS 域名查询开始的UNIX时间戳,如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和fetchStart一致。
        domainLookupEnd: DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等
        connectStart: HTTP（TCP） 域名查询结束的时间戳，如果使用了持续连接(persistent connection)，或者这个信息存储到了缓存或者本地资源上，这个值将和 fetchStart一致。
        connectEnd: HTTP（TCP） 返回浏览器与服务器之间的连接建立时的时间戳，如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。
        secureConnectionStart: HTTPS 返回浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。
        requestStart: 返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。
        responseStart: 返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳，如果传输层在开始请求之后失败并且连接被重开，该属性将会被数制成新的请求的相对应的发起时间。
        responseEnd: 返回浏览器从服务器收到（或从本地缓存读取，或从本地资源读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳。
        domLoading: 当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的 readystatechange事件触发时）的时间戳。
        domInteractive: 当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的时间戳。
        domContentLoadedEventStart: 当解析器发送DOMContentLoaded 事件，即所有需要被执行的脚本已经被解析时的时间戳。
        domContentLoadedEventEnd: 当所有需要立即执行的脚本已经被执行（不论执行顺序）时的时间戳。
        domComplete: 当前文档解析完成，即Document.readyState 变为 'complete'且相对应的readystatechange 被触发时的时间戳
        loadEventStart: load事件被发送时的时间戳。如果这个事件还未被发送，它的值将会是0。
        loadEventEnd: 当load事件结束，即加载事件完成时的时间戳。如果这个事件还未被发送，或者尚未完成，它的值将会是0。
}
</code></pre></div><div class="language-angular2 extra-class"><pre class="language-text"><code>// 重定向耗时
redirect: timing.redirectEnd - timing.redirectStart,
// DOM 渲染耗时
dom: timing.domComplete - timing.domLoading,
// 页面加载耗时
load: timing.loadEventEnd - timing.navigationStart,
// 页面卸载耗时
unload: timing.unloadEventEnd - timing.unloadEventStart,
// 请求耗时
request: timing.responseEnd - timing.requestStart,
// 获取性能信息时当前时间
time: new Date().getTime(),

//白屏时间指从输入网址，到页面开始显示内容的时间。
&lt;script&gt;
    let whiteScreen = new Date() - performance.timing.navigationStart
&lt;/script&gt;
</code></pre></div><h2 id="js-实现一个单例模式"><a href="#js-实现一个单例模式" class="header-anchor">#</a> js 实现一个单例模式</h2> <p>思路：保证一个类只有一个对象，一般先判断对象是否存在，如果存在直接返回该对象。如果不存在，创建对象并返回。
比如后台的 jdbc 连接就是典型的单例，防止每次使用 sql 都要创建 sql 连接对象。</p> <h2 id="requestanimationframe-对比-settimeout"><a href="#requestanimationframe-对比-settimeout" class="header-anchor">#</a> requestAnimationFrame 对比 setTimeOut</h2> <ul><li>没有办法保证，回调函数一定会在 setTimeout()指定的时间执行。</li> <li>把浏览器切换到后台，setTimeOut 还会一直执行。</li> <li>在页面渲染结束后才会开始执行。</li> <li>requestAnimationFrame 执行时机早，在重绘阶段 就开始执行了。</li> <li>动画更加流畅 60 帧/s，既 16.67ms 更新一次视图。这个时机是符合人眼的。频率是自己定的</li> <li>setTimeOut 手动设置多少毫秒增加多少像素，requestAnimationFrame 自动控制.
setTimeOut 手动设置时间来执行，如果手动设置 setTimeOut(fn,0)执行代码前等待的毫秒数为 0，但并不是立即执行的，这是因为 setTimeout 有一个最小执行时间。</li></ul> <p>HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔）不得低于 4 毫秒。实际上可能为 4 毫秒后才事件推入任务队列。如果此时主线程不为空，也不会读取推出异步队列的 setTimeOut.</p> <p>执行效率问题</p> <div class="language- extra-class"><pre class="language-text"><code>虽然两段代码执行效果一样，但是第二段代码(16.7ms/3)就要执行一次函数，很浪费性能。
如果每次增加10或者更大，使用setTimeOut会有明显卡顿卡。
let currentWidth = 100
const maxWidth = 640
function animate()
    currentWidth + = 3;
    if(currentWidth&lt;maxWidth){
        $div.css('left',currentWidth)
        setTimeOut(animate,16.7)
    }
}
animate();

//假设我们让每次增加1px
let currentWidth = 100
const maxWidth = 640
function animate()
    currentWidth + = 1;//每次增加1px
    if(currentWidth&lt;maxWidth){
        $div.css('left',currentWidth)
        setTimeOut(animate,16.7/3) //增加setTimeOut的执行频率
    }
}
animate();
</code></pre></div><h2 id="amd-和-cmd-的区别"><a href="#amd-和-cmd-的区别" class="header-anchor">#</a> AMD 和 CMD 的区别？</h2> <ul><li><p>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p></li> <li><p>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。</p></li> <li><p>1 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。</p></li> <li><p>2 CMD 推崇依赖就近，AMD 推崇依赖前置。</p></li></ul> <h2 id="documentfragement-vs-document"><a href="#documentfragement-vs-document" class="header-anchor">#</a> DocumentFragement VS Document</h2> <p>for in 对比 for of</p> <ul><li>区别:DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</li></ul> <p>DocumentFragment 节点代表一个文档的片段，本身是一个完整的 DOM 树结构。它没有父节点，不属于 Document。但是可以插入任意数量的子节点。但是它不属于当前文档。比直接操作 DOM 树快。</p> <div class="language- extra-class"><pre class="language-text"><code>//简单使用
var carInfoEl = document.querySelector('.car-info')
const fragment = document.createDocumentFragment() //创建fragement
carDetail.carInfo.map(item =&gt; {
      var li = document.createElement('li')
      li.innerHTML = '&lt;span class=&quot;key&quot;&gt;' + item.split(':')[0] + '&lt;/span &gt; &lt;span span class=&quot;value&quot; &gt;' + item.split(':')[1] + '&lt;/span&gt;'
      fragment.appendChild(li)//把真实DOM append到 fragement上
})
carInfoEl.appendChild(fragment) //把fragement添加到真实DOM上。
</code></pre></div><h2 id="在前端如何处理几万条数据的情况"><a href="#在前端如何处理几万条数据的情况" class="header-anchor">#</a> 在前端如何处理几万条数据的情况？</h2> <p>通过使用 DocumentFragement。存储每次要插入的文档。
使用 requestAnimationFragement 动态 在真实 DOM 上添加 fragement。</p> <div class="language- extra-class"><pre class="language-text"><code>    setTimeout(() =&gt; {
    // 插入十万条数据
    const total = 100000;
    // 一次插入的数据
    const once = 20;
    // 插入数据需要的次数
    const loopCount = Math.ceil(total / once);
    let countOfRender = 0;
    const ul = document.querySelector('ul');
    // 添加数据的方法
    function add() {
        const fragment = document.createDocumentFragment();
        for(let i = 0; i &lt; once; i++) {
        const li = document.createElement('li');
        li.innerText = Math.floor(Math.random() * total);
        fragment.appendChild(li);
        }
        ul.appendChild(fragment);
        countOfRender += 1;
        loop();
    }
    function loop() {
        if(countOfRender &lt; loopCount) {
        window.requestAnimationFrame(add);
        }
    }
    loop();
    }, 0)

</code></pre></div><h2 id="promise-状态不能被二次改变问题"><a href="#promise-状态不能被二次改变问题" class="header-anchor">#</a> Promise 状态不能被二次改变问题</h2> <div class="language- extra-class"><pre class="language-text"><code>new Promise(function(resolve,reject){
    resoleve()
    throw Error('error')
}).then(function(){
    console.log('resolve')
}).catch(function(){
    console.log('err')
})
//打印结果 resolve
throw Error 并不会触发 catch 的执行
</code></pre></div><h2 id="原型链问题"><a href="#原型链问题" class="header-anchor">#</a> 原型链问题</h2> <p>此题考察的是对原型链继承关系的理解，和对 new 的认识。</p> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.a = function(){
    console.log('object')
}
Function.prototype.a = function(){
    consoloe.log('function')
}
function A(){

}

let a = new A();
a.a(); // 打印结果是 object，找的是Object上的a
因为 我们new A();首先a会在 构造函数上找，构造函数上找不到。
new的过程
1创建空对象{}
2把a的原型链指向Object
</code></pre></div><h2 id="js-模块的导出和引入"><a href="#js-模块的导出和引入" class="header-anchor">#</a> js 模块的导出和引入</h2> <ul><li>1 在 js 模块中通过 import 导入其他文件 import xxx from '路径地址'</li> <li>2 导出分为两种导出方式 export 和 export default</li></ul> <p>export 具名导出</p> <div class="language-angular2 extra-class"><pre class="language-text"><code>//文件1
//第一个js文件
这种导出方式在导入的时候名字必须与导出名字一致，并且导出多个数据的时候必须写成对象的形式，然后我们在第二个js文件中通过下面代码导入第一个js文件
var name = &quot;名字&quot;;
function fun(){
    alert(&quot;肉弹葱鸡&quot;)
}
export {name,fun}

//第二个js文件
import {name,fun} from '第一个js文件路径'
</code></pre></div><p>export default（匿名导出）</p> <p>匿名导出只能导出一次。</p> <div class="language-angular2 extra-class"><pre class="language-text"><code>class Person{
    constructor(name){
        this.name = name;
    }
    say(){
        alert(this.name)
    }
}

export default Person //将Person匿名导出

import Person from '上面文件路径'
</code></pre></div><h2 id="函数提升和变量提升"><a href="#函数提升和变量提升" class="header-anchor">#</a> 函数提升和变量提升</h2> <ul><li>函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖</li></ul> <p>变量提升</p> <div class="language-angular2html extra-class"><pre class="language-text"><code>
console.log(foo); // undefined
var foo = 'kira';
console.log(foo)  // kira

//相当于

var foo
console.log(foo)
foo = 'kira'
console.log(foo
)
</code></pre></div><p>函数提升</p> <div class="language-angular2html extra-class"><pre class="language-text"><code>
function foo () {
    // to do...
}

//相当于

var foo = function(){
    // to do ...
}
</code></pre></div><div class="language-angular2html extra-class"><pre class="language-text"><code>
console.log(bar);  // f bar() { console.log(123) }
console.log(bar()); // undefined
var bar = 456;
function bar() {
    console.log(123); // 123
}
console.log(bar); // 456
bar = 789;
console.log(bar); // 789
console.log(bar()) // bar is not a function

//相当于

var bar = function(){
    console.log(123)
}
var bar;

bar = 456;

console.log(bar) // 456
bar = 789
console.log(bar) // 789
console.log(bar()) //bar is not function


</code></pre></div><h2 id="小程序-navigateto-和-redirectto-用法和区别"><a href="#小程序-navigateto-和-redirectto-用法和区别" class="header-anchor">#</a> 小程序 navigateTo()和 redirectTo()用法和区别</h2> <ul><li>navigateTo 路由跳转</li> <li>A 页面 redirectTo B 页面，会把 A 在历史记录栈里清掉，在跳转到 B 页面。</li></ul> <h2 id="for-in-对比-for-of"><a href="#for-in-对比-for-of" class="header-anchor">#</a> for in 对比 for of</h2> <h3 id="for-in-是为普通对象设计的"><a href="#for-in-是为普通对象设计的" class="header-anchor">#</a> for-in 是为普通对象设计的</h3> <h3 id="for-of-遍历数组更加方便"><a href="#for-of-遍历数组更加方便" class="header-anchor">#</a> for-of 遍历数组更加方便</h3></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/zhaohongwei978/edit/master/docs/about/question/js.md" target="_blank" rel="noopener noreferrer">在github上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/20/2020, 12:34:31 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/about/question/vue.html" class="prev">
        vue相关
      </a></span> <span class="next"><a href="/about/question/移动端问题.html">
        移动端问题
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/assets/js/app.65d339c7.js" defer></script><script src="/assets/js/2.deebf64a.js" defer></script><script src="/assets/js/39.aefb1b3a.js" defer></script><script src="/assets/js/5.e38e9f60.js" defer></script>
  </body>
</html>
